<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this file,
   - You can obtain one at http://mozilla.org/MPL/2.0/. -->
<!DOCTYPE html>
<html platform="win"><head>
  <meta http-equiv="Content-Security-Policy" content="default-src chrome:; img-src data: *; media-src *; object-src 'none'">
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
  <meta name="viewport" content="width=device-width; user-scalable=0">
  <link rel="stylesheet" href="chrome://global/skin/aboutReader.css" type="text/css">
  <link rel="stylesheet" href="chrome://global/skin/aboutReaderPocket.css" type="text/css">
<link rel="stylesheet" href="chrome://global/skin/narrate.css"><title>Lock-free структуры данных. Основы: откуда пошли быть барьеры памяти</title><link rel="shortcut icon" href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"></head>

<body class="light sans-serif loaded" style="--font-size: 20px; --content-width: 30em;">
  <div class="top-anchor"></div>

  <div id="toolbar" class="toolbar-container">
    <div class="toolbar reader-toolbar">
      <div class="reader-controls" articledir="ltr">
        <button class="close-button button " data-telemetry-id="reader-close" aria-label="Закрыть Вид для чтения"><span class="hover-label">Закрыть Вид для чтения</span></button>
        <ul class="dropdown style-dropdown">
          <li>
            <button class="dropdown-toggle button style-button" data-telemetry-id="reader-type-controls" aria-label="Настройка шрифтов"><span class="hover-label">Настройка шрифтов</span></button>
          </li>
          <li class="dropdown-popup">
            <div class="dropdown-arrow"></div>
            <div class="font-type-buttons radiorow"><input id="radio-itemsans-serif-button" type="radio" class="radio-button" name="font-type" checked="checked"><label for="radio-itemsans-serif-button" class="sans-serif-button" checked="true">Без засечек</label><input id="radio-itemserif-button" type="radio" class="radio-button" name="font-type"><label for="radio-itemserif-button" class="serif-button">С засечками</label></div>
            <div class="font-size-buttons buttonrow">
              <button class="minus-button" title="Уменьшить размер шрифта"></button>
              <span class="font-size-value">5</span>
              <button class="plus-button" title="Увеличить размер шрифта">
            </button></div>
            <div class="content-width-buttons buttonrow">
               <button class="content-width-minus-button" title="Уменьшить ширину содержимого"></button>
               <span class="content-width-value">3</span>
               <button class="content-width-plus-button" title="Увеличить ширину содержимого">
            </button></div>
            <div class="line-height-buttons buttonrow">
                <button class="line-height-minus-button" title="Уменьшить междустрочный интервал"></button>
                <span class="line-height-value">4</span>
                <button class="line-height-plus-button" title="Увеличить междустрочный интервал">
            </button></div>
            <div class="color-scheme-buttons radiorow"><input id="radio-itemlight-button" type="radio" class="radio-button" name="color-scheme" checked="checked"><label for="radio-itemlight-button" class="light-button" checked="true" title="Цветовая схема «Светлая»">Светлый</label><input id="radio-itemdark-button" type="radio" class="radio-button" name="color-scheme"><label for="radio-itemdark-button" class="dark-button" title="Цветовая схема «Тёмная»">Темный</label><input id="radio-itemsepia-button" type="radio" class="radio-button" name="color-scheme"><label for="radio-itemsepia-button" class="sepia-button" title="Цветовая схема «Сепия»">Сепия</label></div>
          </li>
        </ul>
      <ul class="dropdown narrate-dropdown"><li><button class="dropdown-toggle button narrate-toggle" data-telemetry-id="reader-listen" aria-label="Прослушать" hidden=""><span class="hover-label">Прослушать</span></button></li><li class="dropdown-popup"><div class="narrate-row narrate-control"><button class="narrate-skip-previous" disabled="disabled" title="Назад"></button><button class="narrate-start-stop" title="Начать"></button><button class="narrate-skip-next" disabled="disabled" title="Вперёд"></button></div><div class="narrate-row narrate-rate"><input class="narrate-rate-input" value="0" step="5" max="100" min="-100" type="range" title="Скорость"></div><div class="narrate-row narrate-voices"><div class="voiceselect voice-select"><button class="select-toggle" aria-controls="voice-options">
      <span class="label">Голос:</span> <span class="current-voice"></span>
    </button>
    <div class="options" id="voice-options" role="listbox"></div></div></div><div class="dropdown-arrow"></div></li></ul><button data-buttonid="pocket-button" data-telemetry-id="reader-save-to-pocket" class="button pocket-button" aria-label="Сохранить в Pocket" style="background-image: url(&quot;chrome://global/skin/icons/pocket.svg&quot;); background-size: 16px 16px;"><span class="hover-label">Сохранить в Pocket</span></button></div>
    </div>
  </div>

  <div class="container" style="--line-height: 1.6em;" dir="ltr">
    <div class="header reader-header reader-show-element">
      <a class="domain reader-domain" href="https://habr.com/ru/post/196548/">habr.com</a>
      <div class="domain-border"></div>
      <h1 class="reader-title">Lock-free структуры данных. Основы: откуда пошли быть барьеры памяти</h1>
      <div class="credits reader-credits">Максим Хижинский</div>
      <div class="meta-data">
        <div class="reader-estimated-time" dir="ltr">33-47 минут</div>
      </div>
    </div>

    <hr>

    <div class="content">
      <div class="moz-reader-content reader-show-element"><div id="readability-page-1" class="page"><div id="post-content-body" data-gallery-root="" lang="ru"><p><img src="Lock-free%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D0%BE%D1%82%D0%BA%D1%83%D0%B4%D0%B0%20%D0%BF%D0%BE%D1%88%D0%BB%D0%B8%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%B1%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D1%8B%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_files/78b46bd2a01a37adca15fb0236bd9338.jpg" data-src="https://habrastorage.org/getpro/habr/post_images/78b/46b/d2a/78b46bd2a01a37adca15fb0236bd9338.jpg"><br>
Как только я заинтересовался lock-free алгоритмами, меня стал мучить 
вопрос – а откуда взялась необходимость в барьерах памяти, в «наведении 
порядка» в коде? <br>
Конечно, прочитав несколько тысяч страниц руководств по <i>конкретной</i> архитектуре, мы найдем ответ. Но этот ответ будет годен для этой <i>конкретной</i>
 архитектуры. Есть ли общий? В конце концов, мы же хотим, чтобы наш код 
был портабелен. Да и модель памяти C++11 не заточена под конкретный 
процессор.<br>
Наиболее приемлемый общий ответ дал мне мистер <a href="http://www.linkedin.com/in/paulmckenney">Paul McKenney</a> в своей статье 2010 года <a href="http://irl.cs.ucla.edu/~yingdi/web/paperreading/whymb.2010.06.07c.pdf">Memory Barriers: a Hardware View of Software Hackers</a>.
 Ценность его статьи – в общности: он построил некоторую упрощенную 
абстрактную архитектуру, на примере которой и разбирает, что такое 
барьер памяти и зачем он был введен.<br>
Вообще, Paul McKenney – известная личность. Он является разработчиком и активным пропагандистом технологии <a href="http://en.wikipedia.org/wiki/Read-copy-update">RCU</a>, которая активно используется в ядре Linux, а также реализована в последней версии <a href="http://libcds.sourceforge.net/">libcds</a>
 в качестве ещё одного подхода к безопасному освобождению памяти 
(вообще, о RCU я хотел бы рассказать отдельно). Также принимал участие в
 работе над моделью памяти C++11. <br>
Статья большая, я даю перевод только первой половины. Я позволил себе добавить некоторые комментарии, <i>[которые выделены в тексте так]</i>.<br>
<a name="habracut"></a></p><h2>Memory Barriers: a Hardware View of Software Hackers</h2><p>
Что подвигло дизайнеров CPU ввести барьеры памяти и тем самым подложить 
свинью разработчикам? Короткий ответ таков: переупорядочение обращений к
 памяти позволяет достичь лучшей производительности, а барьеры памяти 
нужны для «наведения порядка» в вещах типа примитивов синхронизации <i>[и lock-free алгоритмов, естественно]</i>, где корректность примитива зависит как раз от порядка обращений к памяти. <br>
Детальный ответ требует хорошего понимания того, как работает кэш CPU, и
 что требуется для ещё лучшей его работы. Поэтому далее мы:</p><ul>
<li>рассмотрим структуру кэша;</li>
<li>опишем, как протокол когерентности кэша обеспечивает видимость каждой ячейки памяти для разных процессоров;</li>
<li>рассмотрим, как буферы записи (store buffers) и очереди инвалидаций 
(invalidate queues) помогают кэшу достичь максимальной 
производительности.</li>
</ul><p>
Мы увидим, что барьеры памяти есть необходимое зло, требующееся для 
достижения высокой производительности и масштабируемости. Корнем этого 
зла является тот факт, что CPU на порядки быстрее, чем память и 
интерфейс процессора с памятью.</p><h2>Структура кэша</h2>
<p><img data-src="https://habrastorage.org/getpro/habr/post_images/2f8/e85/f42/2f8e85f42c64689016bf981ebdb048ff.png" src="Lock-free%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D0%BE%D1%82%D0%BA%D1%83%D0%B4%D0%B0%20%D0%BF%D0%BE%D1%88%D0%BB%D0%B8%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%B1%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D1%8B%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_files/2f8e85f42c64689016bf981ebdb048ff.png"><br>
Современные CPU намного быстрее подсистемы памяти. Процессор образца 
2006 года мог выполнять 10 инструкций в наносекунду, но требовалось 
много десятков наносекунд для извлечения данных из основной памяти. Эта 
диспропорция в скорости (более чем на два порядка!) привела к 
многомегабайтным кэшам у современных процессоров. Кэши принадлежат 
процессорам и, как правило, время доступа к ним — несколько тактов.</p><div><p><b>Примечание</b></p><p>На
 самом деле, устоявшейся практикой является наличие нескольких уровней 
кэша. Самый маленький по объему кэш находится ближе всего к процессору и
 доступен за один такт. Кеш второго уровня имеет время доступа порядка 
10 тактов. Наиболее производительные процессоры имеют 3 и даже 4 уровня 
кэшей<br>
</p></div><p>
CPU обменивается данными с кэшем блоками, называемыми <i>кэш-линиями</i>
 (cache line), размер которых обычно является степенью двойки – от 16 до
 256 байт (зависит от CPU). Когда к ячейке памяти впервые обращается 
процессор, ячейка отсутствует в кэше, — эта ситуация называется <i>промахом</i>
 (cache miss или, более точно, “startup” или “warmup” cache miss). 
Промах означает, что CPU должен ждать (stalled) сотни тактов, пока 
данные не будут извлечены из памяти. Наконец данные будут загружены в 
кэш, и последующие обращения по данному адресу найдут данные в кэше, так
 что CPU будет работать на полной скорости.<br>
Спустя некоторое время кэш заполнится, и промахи будут приводить к 
вытеснению данных из кэша, чтобы дать место новым запрашиваемым данным. 
Такие промахи называются <i>промахами по переполнению</i> (capacity 
miss). Более того, вытеснение может произойти даже тогда, когда кэш не 
полон, так как он организован в железе в виде хеш-таблицы с 
фиксированным размером <a href="http://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0">bucket’а</a> (или <i>набора</i>, как его зовут разработчики CPU).<br>
<img data-src="https://habrastorage.org/getpro/habr/post_images/003/246/49a/00324649ad5fd3fdf68f199181ff94d8.png" src="Lock-free%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D0%BE%D1%82%D0%BA%D1%83%D0%B4%D0%B0%20%D0%BF%D0%BE%D1%88%D0%BB%D0%B8%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%B1%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D1%8B%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_files/00324649ad5fd3fdf68f199181ff94d8.png"><br>
На рисунке справа представлен 2-ассоциативный (2-way) кэш с cache line 
размером 256 байт. Линия может быть пустой, что соответствует пустой 
ячейке таблицы. Числа слева – это адреса, данные которых может содержать
 ячейка. Так как линии выравнены по 256 байтам, младшие 8 бит адреса 
равны нулю, и хеш-функция выбирает следующие 4 бита в качестве индекса в
 хеш-таблице. Предположим, код программы расположен по адресам 
0x43210E00 – 0x43210EFF, а сама программа последовательно обращается к 
данным по адресам 0x12345000 – 0x12345EFF. Пусть теперь она обращается к
 адресу 0x12345F00. Этот адрес хешируется на линию 0xF и обе ячейки 
(ways) этой линии пусты, так что 256 байт данных можно поместить в одну 
из них. Если программа обращается по адресу 0x1233000, хеш которой равен
 0x0, то соответствующие 256-байтные данные могут быть помещены в ячейку
 1 (way 1) линии 0x0. Если же программа обращается по адресу 0x1233E00 
(хеш = 0xE), то одна из линий (ways) должна быть вытолкнута из кэша, 
чтобы освободить место под новые 256 байт данных. Если позже потребуется
 доступ к этим вытолкнутым данным, — получаем ситуацию промаха. Такой 
промах называется associativity miss.<br>
Все это относится к чтению данных, а что будет при записи? Все CPU 
должны быть согласованы по данным, так что перед тем как записать, нужно
 удалить (invalidate) данные из кэшей других CPU. Только после того, как
 инвалидация завершится, процессор может безопасно записать данные. Если
 данные находятся в кэше CPU, но являются read-only, это называется <i>промахом записи</i>
 (write miss). Только после того, как CPU инвалидирует такие данные в 
кэшах других процессоров, CPU может повторно записать (и прочитать) эти 
данные. Далее, если какой-то CPU попытается обратиться к данным в то 
время, как другой CPU их инвалидировал для записи, — он получит промах, 
зовущийся <i>communication miss</i>, так как такая ситуация возникает, 
когда данные используются для взаимодействия (communication), как, 
например, мьютекс или spin-lock <i>[имеется в виду сам мьютекс, а не данные, которые он защищает; мьютекс – это какой-то флаг]</i>.<br>
Как видно, большие усилия должны быть приложены для того, чтобы управлять <i>когерентностью</i>
 данных для всех CPU. Со всеми этими чтением/инвалидацией/записью легко 
вообразить, что данные будут потеряны или (что ещё хуже) у разных CPU 
будут разные данные в их кэшах. Эти проблемы решает <i>протокол когерентности данных</i> (cache-coherency protocol)</p><h2>Cache coherency protocol</h2><p>
Протокол управляет состоянием линий кэша, обеспечивая целостность и 
запрещая потерю данных. Такие протоколы могут быть очень сложными, с 
десятками состояний, но для наших целей достаточно рассмотреть протокол 
MESI, имеющий 4 состояния.</p><h3>Состояния MESI</h3><p>
MESI – это 4 возможных состояния кэш-линии: 
Modified-Exclusive-Shared-Invalid. Для поддержки этого протокола каждая 
линия, помимо собственно данных, должна иметь двухбитовый тег, хранящий 
её состояние.<br>
Состояние <i>Modified</i> означает, что данные в кэш-линии только что 
записаны процессором-владельцем кэша, и гарантируется, что изменение ещё
 не появилось в кэшах других CPU. Можно сказать, что данными владеет 
один CPU. Так как данные в такой линии свежайшие, линия кэша готова к 
записи в память (или в кэш следующего уровня), и запись должна быть 
произведена прежде, чем линию можно будет заполнить другими данными.<br>
Состояние <i>Exclusive</i> весьма похоже на Modified, за исключением 
того, что данные ещё не изменены процессором-владельцем кэша. Это, в 
свою очередь, означает, что линия содержит наисвежайшие данные, 
согласованные с памятью. CPU-владелец может писать в эту кэш-линию в 
любое время без оповещения других CPU, равно как и вытеснить её без 
какой-либо записи обратно в память.<br>
Состояние <i>Shared</i> говорит, что линия продублирована по крайней 
мере в ещё одном кэше другого CPU. CPU-владелец такой линии не может 
писать в неё без предварительного согласования с другими CPU. Как и для 
состояния Exclusive, линия согласована с памятью, и может быть вытеснена
 без оповещения других CPU и без записи обратно в память.<br>
Линия кэша в состоянии <i>Invalid</i> пуста, то есть не содержит никаких
 данных (или содержит мусор). Когда в кэш требуется подгрузить новые 
данные, они по возможности помещаются в Invalid-линию. <br>
Так как все CPU должны поддерживать когерентность кэшей системы в целом,
 протокол описывает сообщения, с помощью которых координируются 
изменения состояния линий кэша всех процессоров.</p><h3>Сообщения протокола MESI</h3><p>
Многие из переходов из одного состояния в другое требуют взаимодействия 
между CPU. Если все CPU подсоединены к единой разделяемой шине, 
достаточно следующих сообщений:</p><ul>
<li><b>Read</b> (Чтение): это сообщение содержит физический адрес читаемой кэш-линии</li>
<li><b>Read Response</b> (Ответ на чтение): содержит данные, запрошенные предыдущим сообщением <i>Read</i>. <i>Read Response</i>
 может прийти от подсистемы памяти или от другого кэша. Например, если 
данные уже находятся в каком-либо кэше в состоянии “modified”, то такой 
кэш может ответить на <i>Read</i></li>
<li><b>Invalidate</b> (Инвалидация): содержит физический адрес кэш-линии, которую требуется инвалидировать. <i>Все</i> прочие кэши должны удалить данные и ответить на это сообщение.</li>
<li><b>Invalidate Acknowledge</b> (Подтверждение инвалидации): CPU, получивший <i>Invalidate</i>, должен удалить требуемые данные и подтвердить это сообщением <i>Invalidate Acknowledge</i></li>
<li><b>Read Invalidate</b> (Чтение с инвалидацией): это сообщение 
содержит физический адрес читаемой кэш-линии. В то же время оно диктует 
другим кэшам удалить эти данные. По сути, это комбинация сообщений <i>Read</i> и <i>Invalidate</i>. Это сообщение требует ответа <i>Read Response</i> и множества <i>Invalidate Acknowledge</i></li>
<li><b>Writeback</b> (Запись в память): содержит адрес и собственно 
данные для записи в память. Разрешает кэшам очистить соответствующую 
линию в состоянии <i>Modified</i></li>
</ul><p>
Как видите, мультипроцессорная машина – это система передачи сообщений, по сути компьютер под крышкой процессора.</p><div><p><b>Вопрос-ответ</b></p><p><i>Что произойдет, если два процессора будут инвалидировать одну и ту же кэш-линию одновременно?</i> <br>
Один из них (“победитель”) получит доступ к разделяемой шине первым. 
Другие CPU должны инвалидировать свои копии этой кэш-линии и ответить 
подтверждением “invalidate acknowledge”. Конечно, “проигравший” CPU 
может тут же инициировать транзакцию “read invalidate”, так что победа 
может оказаться эфемерной.<br>
<i>Если сообщение “invalidate” появится в большой многопроцессорной 
системе, все CPU должны ответить “invalidate acknowledge”. Не приведет 
ли взрывной поток таких ответов к полной остановке системы?</i><br>
Да, может привести, если большая (large-scale) система построена таким 
образом. Но такие системы, как, например, NUMA, обычно используют <i>directory-based</i> <i>[directory в NUMA – узел, node]</i> протокол поддержки когерентности кэшей как раз для предотвращения таких случаев.<br>
</p></div><h3>Диаграмма состояний MESI</h3>
<p><img data-src="https://habrastorage.org/getpro/habr/post_images/b39/f5d/190/b39f5d1905719c3ef3d2cf4a927a6d64.png" src="Lock-free%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D0%BE%D1%82%D0%BA%D1%83%D0%B4%D0%B0%20%D0%BF%D0%BE%D1%88%D0%BB%D0%B8%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%B1%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D1%8B%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_files/b39f5d1905719c3ef3d2cf4a927a6d64.png"><br>
Переходы на рисунке справа имеют следующее значение:</p><ul>
<li><b>Переход a (M -&gt; E)</b>: Кэш-линия записана обратно в память, 
но CPU оставил её в кэше и имеет право изменять её. Этот переход требует
 сообщения “writeback”.</li>
<li><b>Переход b (E -&gt; M)</b>: CPU пишет в кэш-линию, к которой имеет эксклюзивный доступ. Этот переход не требует каких-либо сообщений.</li>
<li><b>Переход c (M -&gt; I)</b>: CPU получает сообщение “read 
invalidate” кэш-линии в состоянии “Modified”. CPU должен удалить свою 
локальную копию и ответить сообщениями “read response” и “invalidate 
acknowledge”. Тем самым CPU отправляет данные и показывает, что более не
 имеет их копии у себя</li>
<li><b>Переход d (I -&gt; M)</b>: CPU производит read-modify-write (RMW)
 операцию над данными, не находящимися в кэше. Он издает “read 
invalidate” сигнал, получая данные в “read response”. CPU завершает 
переход только когда получит все ответы “invalidate acknowledge”</li>
<li><b>Переход e (S -&gt; M)</b>: CPU производит read-modify-write (RMW)
 операцию над данными, которые были read-only. Он должен инициировать 
“invalidate” сигнал и ждать, пока не получит полный набор ответов 
“invalidate acknowledge”</li>
<li><b>Переход f (M -&gt; S)</b>: Какой-то другой процессор читает 
данные, и эти данные находятся в кэше нашего CPU. В результате данные 
становятся read-only, что может привести к записи в память. Этот переход
 инициируется приемом сигнала “read”. CPU отвечает сообщением “read 
response”, содержащим запрашиваемые данные</li>
<li><b>Переход g (E -&gt; S)</b>: Какой-то другой процессор читает 
данные, и эти данные находятся в кэше нашего CPU. Данные становятся 
разделяемыми и, следовательно, read-only. Переход инициируется приемом 
сигнала “read”. CPU отвечает сообщением “read response”, содержащим 
запрашиваемые данные </li>
<li><b>Переход h (S -&gt; E)</b>: CPU решает, что ему надо записать 
данные в кэш-линию, и поэтому посылает “invalidate” сообщение. Переход 
не завершается, пока CPU не получит полный набор ответов “invalidate 
acknowledge”. Другие CPU выкидывают кэш-линию из своих кэшей сообщением 
“writeback”, так что наш CPU становится единственным, кэширующим эти 
данные</li>
<li><b>Переход i (E -&gt; I)</b>: Другой CPU выполняет RMW-операцию с 
данными, которыми владеет наш CPU, так что наш процессор инвалидирует 
кэш-линию. Переход начинается с сообщения “read invalidate”, наш CPU 
отвечает сообщениями “read response” и “invalidate acknowledge”.</li>
<li><b>Переход j (I -&gt; E)</b>: CPU сохраняет данные в новую кэш-линию
 и передает сообщение “read invalidate”. CPU не может закончить переход,
 пока не получит “read response” и полный набор “invalidate 
acknowledge”. Как только запись завершится, кэш-линия переходит в 
состояние “modified” через переход (b)</li>
<li><b>Переход k (I -&gt; S)</b>: CPU загружает данные в новую кэш-линию. CPU посылает “read”-сообщение и завершает переход, получив “read response”</li>
<li><b>Переход l (S -&gt; I)</b>: Другой CPU хочет сохранить данные в 
кэш-линию, которая имеет статус read-only, так как какой-то третий CPU 
(или, например, наш) разделяет данные с нами. Переход начинается приемом
 “invalidate”, и наш CPU отвечает “invalidate acknowledge”</li>
</ul><br>
<div><p><b>Вопрос-ответ</b></p><p><i>Как железо обрабатывает такие тяжелые переходы, требующие многочисленных задержек?</i><br>
Обычно – введением дополнительных состояний. Но такие состояния не 
требуется сохранять в кэш-линиях, то есть они не являются состояниями 
кэш-линии. В каждый момент времени только несколько кэш-линий могут 
находиться в переходном состоянии. Именно наличие тяжелых, 
распределенных во времени переходов является причиной того, что реальные
 протоколы поддержки когерентности кэша намного сложнее, чем упрощенный 
MESI, описываемый здесь.<br>
</p></div><h3>Пример протокола MESI</h3><p>
Давайте посмотрим, как работает MESI с точки зрения кэш-линии, на 
примере 4-процессороной системы с прямым отображением памяти в кэш. 
Данные находятся в памяти по адресу 0. Следующая таблица иллюстрирует 
изменение данных. Первая колонка – это последовательный номер операции, 
вторая – номер процессора, выполняющего операцию, третья – какая 
операция выполняется, следующие четыре колонки – состояние кэш-линии 
каждого CPU (в виде адрес памяти/состояние), заключительные две колонки –
 содержит ли память корректные данные (V) или нет (I).<br>
<img data-src="https://habrastorage.org/getpro/habr/post_images/a99/e79/82a/a99e7982a91c478da76845119766a52f.png" src="Lock-free%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D0%BE%D1%82%D0%BA%D1%83%D0%B4%D0%B0%20%D0%BF%D0%BE%D1%88%D0%BB%D0%B8%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%B1%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D1%8B%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_files/a99e7982a91c478da76845119766a52f.png"><br>
Сначала линии кэша CPU находятся в состоянии “invalid”, а память 
содержит корректные данные. Когда CPU 0 читает данные по адресу 0, 
кэш-линия CPU 0 переходит в состояние “shared” и согласована с памятью. 
CPU 3 также читает данные по адресу 0, так что кэш-линии переходят в 
состояние “shared” в кэшах обоих CPU, но по-прежнему согласованы с 
памятью. Далее CPU 0 загружает данные по адресу 8, что приводит к 
вытеснению кэш-линии и помещению в неё новых данных (прочитанных по 
адресу 8). Далее, CPU 2 читает данные по адресу 0, но затем понимает, 
что ему необходимо записать их (RMW-операция), так что он использует 
сигнал “read invalidate”, чтобы убедиться, что он имеет эксклюзивную 
копию данных. Сигнал “read invalidate” инвалидирует кэш-линию CPU 3 
(хотя его данные пока остаются согласованными с памятью). Затем CPU 2 
выполняет запись, являющуюся составной частью RMW-операции, что 
переводит кэш-линию в состояние “Modified”. Данные в памяти теперь 
устаревшие. CPU 1 выполняет атомарный инкремент и использует сигнал 
“read invalidate”, чтобы получить данные. Данные он получает из кэша CPU
 2, а в самом CPU 2 данные инвалидируются. В результате данные находятся
 в кэш-линии CPU 1 в состоянии “modified” и по-прежнему не согласованы с
 памятью. Наконец, CPU 1 читает данные по адресу 8, что приводит к 
сбросу кэш-линии в память (используется сообщение “writeback”).</p><div><p><b>”Вопрос-ответ”</b></p><p><i>Кэш
 содержит некоторые данные, когда мы остановили наш пример. А какая 
последовательность операций должна быть, чтобы перевести линии кэша всех
 CPU в состояние “invalidate”?</i><br>
Такой последовательности не существует, разве что CPU поддерживает 
специальную инструкцию сброса кэша (“flush my cache”). У большинства 
процессоров такая инструкция есть<br>
</p></div><p>

<img data-src="https://habrastorage.org/getpro/habr/post_images/64d/664/80b/64d66480b53046f7f1e529456e6a4b05.png" src="Lock-free%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D0%BE%D1%82%D0%BA%D1%83%D0%B4%D0%B0%20%D0%BF%D0%BE%D1%88%D0%BB%D0%B8%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%B1%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D1%8B%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_files/64d66480b53046f7f1e529456e6a4b05.png"></p><h2>Нежелательные простои при записи</h2><p>
Хотя структура кэша, рассмотренная нами ранее, обеспечивает хорошую 
производительность чтения/записи данных для CPU, владеющего этими 
данными, производительность <i>первой</i> записи в конкретную кэш-линию очень плоха. Чтобы увидеть это, рассмотрим рисунок справа.<br>
Рисунок демонстрирует задержку записи процессором 0 кэш-линии, которая 
находится в кэше CPU 1. CPU 0 должен ждать довольно продолжительный 
период времени, пока кэш-линия станет доступна для записи, — перейдет из
 кэша CPU 1 во владение CPU 0. Время, необходимое для переноса кэш-линии
 от одного CPU к другому, обычно <i>на порядки</i> выше, чем длительность инструкции, работающей с регистрами. <br>
Но для CPU 0 нет причин ждать так долго: независимо от данных, переданных CPU 1, CPU 0 безусловно перезапишет их.</p><p>

<img data-src="https://habrastorage.org/getpro/habr/post_images/e2a/361/14c/e2a36114c7a247db90e6ec64f35fb26e.png" src="Lock-free%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D0%BE%D1%82%D0%BA%D1%83%D0%B4%D0%B0%20%D0%BF%D0%BE%D1%88%D0%BB%D0%B8%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%B1%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D1%8B%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_files/e2a36114c7a247db90e6ec64f35fb26e.png"></p><h3>Store buffers</h3><p>
Один из методов борьбы с нежелательными простоями – добавить буфер 
записи (store buffer) между каждым CPU и его кэшем, как показано на 
рисунке справа. С таким буфером CPU 0 может просто записать 
write-операцию в свой store buffer и продолжать работу. После 
необходимого обмена сообщениями, когда кэш-линия наконец перейдет от CPU
 1 к CPU 0, данные могут быть перемещены из store buffer в кэш-линию 
процессора 0. <br>
Однако такое решение приводит к дополнительным проблемам, которые мы и рассмотрим в следующих двух разделах.</p><h3>Store Forwarding</h3><p>
Чтобы увидеть первую проблему, называемую нарушением <i>собственной целостности</i> (self-consistency), рассмотрим следующий код:</p><pre><code><span>1</span>	<span>a</span> <span>=</span> <span>1</span><span>;</span>
<span>2</span>	<span>b</span> <span>=</span> <span>a</span> <span>+</span> <span>1</span><span>;</span>
<span>3</span>	<span>assert(</span> <span>b</span> <span>==</span> <span>2</span> <span>);</span>
</code></pre> <p>
Переменные «a» и «b» имеют начальное значение 0. Переменная «a» 
находится в кэше процессора 1, а переменная «b» — в кэше процессора 0.<br>
Казалось бы, как вообще может сработать этот <code>assert</code>? 
Однако, если бы кто-нибудь реализовал процессор с архитектурой как на 
рисунке, он был бы удивлен. Такая система могла бы потенциально выдать 
следующую последовательность событий:</p><ul>
<li>1. CPU 0 начинает выполнять <code>a = 1</code></li>
<li>2. CPU 0 смотрит, находится ли “a” в его кэше, и видит, что нет, — промах</li>
<li>3. Поэтому CPU 0 посылает сигнал “read invalidate”, чтобы получить исключительные права на кэш-линию с “a”</li>
<li>4. CPU 0 записывает “a” в свой store buffer</li>
<li>. CPU 1 получает “read invalidate”-сообщение и отвечает на него, посылая кэш-линию с “a” и удаляя (invalidate) свою кэш-линию</li>
<li>6. CPU 0 начинает выполнять <code>b = a + 1</code></li>
<li>7. CPU 0 получает ответ от CPU 1, который ещё содержит старое, <i>нулевое</i> значение “a”, и помещает линию в свой кэш</li>
<li>8. CPU 0 загружает “a” из своего кэша, — <i>загружается значение ноль</i></li>
<li>9. CPU 0 выполняет сохраненный в store buffer запрос на запись в кэш, записывая в кэш-линию значение “a” = 1</li>
<li>10. CPU 0 добавляет единицу к нулю, прочитанному ранее в качестве 
“a”, и сохраняет результат в кэш-линии “b” (которая, как мы помним, 
находится во владении CPU 0)</li>
<li>11. CPU 0 выполняет <code>assert(b == 2)</code> и выдает ошибку — <code>assert</code> срабатывает</li>
</ul><p>
Проблема в том, что мы имеем две копии “a” – одну в кэше и вторую в store buffer.<br>
<img data-src="https://habrastorage.org/getpro/habr/post_images/92d/495/285/92d495285d5667f0a115e643d871c6bc.png" src="Lock-free%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D0%BE%D1%82%D0%BA%D1%83%D0%B4%D0%B0%20%D0%BF%D0%BE%D1%88%D0%BB%D0%B8%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%B1%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D1%8B%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_files/92d495285d5667f0a115e643d871c6bc.png"><br>
Этот пример нарушает очень важную гарантию: <i>каждый CPU должен всегда выполнять операции в том порядке, как они заданы в программе</i> (так называемый <i>program order</i>). Для программистов эта гарантия является интуитивно понятным требованием, так что hardware-инженеры вынуждены были внедрить <i>store forwarding</i>: каждый CPU читает данные не только из своего кэша, но и <i>обязательно</i>
 из store buffer. Другими словами, каждая операция записи может прямо 
передаваться следующей операции чтения через store buffer, без обращения
 к кэшу.<br>
С store forwarding, шаг 8 в вышеприведенном примере должен прочитать 
корректное значение 1 переменной “a” из store buffer. В результате 
значение “b” станет 2, что нам и требуется.</p><h3>Буферы записи и барьеры памяти</h3><p>
Чтобы увидеть другую проблему, — нарушение <i>глобального порядка памяти</i> (global memory ordering), — рассмотрим следующий пример, в котором переменные “a” и “b” имеют начальное значение 0:</p><pre><code><span>1</span>	<span>void</span> <span>foo()</span>
<span>2</span>	<span>{</span>
<span>3</span>		<span>a</span> <span>=</span> <span>1</span><span>;</span>
<span>4</span>		<span>b</span> <span>=</span> <span>1</span><span>;</span>
<span>5</span>	<span>}</span>
<span>6</span>
<span>7</span>	<span>void</span> <span>bar()</span>
<span>8</span>	<span>{</span>
<span>9</span>		<span>while</span> <span>(</span> <span>b</span> <span>==</span> <span>0</span> <span>)</span> <span>continue;</span>
<span>10</span>		<span>assert(</span> <span>a</span> <span>==</span> <span>1</span> <span>);</span>
<span>11</span>	<span>}</span>
</code></pre><p>
Пусть CPU 0 выполняет <code>foo()</code>, а CPU 1 — <code>bar()</code>. 
Предположим, что память, содержащая “a”, находится только в кэше CPU 1, а
 CPU 0 владеет памятью, содержащей “b”. Тогда возможна следующая 
последовательность действий:</p><ul>
<li>1. CPU 0 выполняет <code>a=1</code>. Кэш-линия для “a” не находится в
 кэше CPU 0, так что CPU 0 помещает новое значение “a” в свой буфер 
записи и издает сигнал “read invalidate”.</li>
<li> 2. CPU 1 выполняет <code>while (b==0) continue</code>, но “b” нет в его кэше, так что он посылает сообщение “read”</li>
<li>3. CPU 0 выполняет <code>b = 1</code>. Он уже владеет “b” в своем 
кэше, то есть соответствующая кэш-линия находится в состоянии 
“exclusive” или “modified”, — так что он имеет полное право сохранить 
новое значение “b” в своем кэше, никому ничего не сообщая</li>
<li>4. CPU 0 получает сообщение “read” и передает в ответе кэш-линию со 
свежайшим значением “b”, попутно переводя эту линию в состояние “shared”
 у себя в кэше</li>
<li>5. CPU 1 получает кэш-линию с “b” и помещает её в свой кэш</li>
<li>6. CPU 1 теперь может завершить выполнение <code>while (b == 0) continue</code>, так как он видит, что <code>b == 1</code>, и приступить к выполнению следующей инструкции</li>
<li>7. CPU 1 выполняет <code>assert(a == 1)</code>. Так как CPU 1 работает со старым значением “a”, условие не выполняется</li>
<li>8. CPU 1 получает сообщение “read invalidate” и передает кэш-линию с
 “a” CPU 0, попутно инвалидируя эту линию в своем кэше. Но слишком 
поздно</li>
<li>9. CPU 0 получает кэш-линию с “a” и выполняет запись из буфера (сбрасывает store buffer в свой кэш)</li>
</ul><br>
<div><p><b>Вопрос-ответ</b></p><p><i>Почему CPU 0 в шаге 1 вынужден слать сообщение “read invalidate”, а не просто “invalidate”?</i><br>
Потому что кэш-линия содержит не только значение переменной “a”. Размер кэш-линии довольно большой.<br>
</p></div><p>
Hardware-инженеры не могут ничем помочь в этом случае, так как 
процессоры ничего не знают про взаимосвязь переменных в программе. 
Поэтому инженеры ввели <i>инструкции барьеров памяти</i>, с помощью которых программисты могут выразить в программе подобные связи данных. Фрагмент программы должен быть изменен так:</p><pre><code><span>1</span>	<span>void</span> <span>foo()</span>
<span>2</span>	<span>{</span>
<span>3</span>		<span>a</span> <span>=</span> <span>1</span><span>;</span>
<span>4</span>		<span>smp_mb();</span>
<span>5</span>		<span>b</span> <span>=1;</span>
<span>6</span>	<span>}</span>
<span>7</span>
<span>8</span>	<span>void</span> <span>bar()</span>
<span>9</span>	<span>{</span>
<span>10</span>		<span>while</span> <span>(</span> <span>b</span> <span>==</span> <span>0</span> <span>)</span> <span>continue;</span>
<span>11</span>		<span>assert(</span> <span>a</span> <span>==</span> <span>1</span> <span>);</span>
<span>12</span>	<span>}</span>
</code></pre><p>
Барьер памяти <code>smp_mb()</code> <i>[это реальная функция из ядра Linux]</i>
 говорит процессору сбросить store buffer перед выполнением следующей 
записи в кэш. CPU может либо просто остановиться, ожидая, пока его store
 buffer не станет пустым, или может использовать store buffer для 
последующих записей, пока все записи, уже находящиеся в store buffer, не
 будут выполнены <i>[тем самым в store buffer наводится некоторый FIFO-порядок]</i>.</p><div><p><b>Последовательность выполнения программы с барьером памяти</b></p><div><ul>
<li>1. CPU 0 выполняет <code>a=1</code>. Кеш-линия для “a” не находится в
 кэше CPU 0, так что CPU 0 помещает новое значение “a” в свой буфер 
записи и издает сигнал “read invalidate”.</li>
<li>2. CPU 1 выполняет <code>while (b==0) continue</code>, но “b” нет в его кэше, так что он посылает сообщение “read”</li>
<li>3. CPU 0 выполняет <code>smp_mb()</code> и помечает (marked) все элементы в своем store buffer (в том числе и <code>a = 1</code>)</li>
<li>4. CPU 0 выполняет <code>b = 1</code>. Он уже владеет “b” (то есть 
соответствующая кэш-линия находится в состоянии “modified” или 
“exclusive”), но в буфере записи есть меченые (marked) элементы. Поэтому
 вместо записи нового значения “b” в свой кэш, он помещает “b” в свой 
буфер записи, но как <i>неотмеченный (unmarked)</i> элемент</li>
<li>5. CPU 0 получает “read”-сообщение и передает кэш-линию с начальным 
значением “b” (=0) процессору 1. Также он меняет состояние кэш-линии на 
“shared”.</li>
<li>6. CPU 1 получает кэш-линию с “b” и помещает её в свой кэш</li>
<li>7. CPU 1 теперь мог бы завершить <code>while (b == 0) continue</code>, но он видит, что <code>b=0</code>, так что он вынужден продолжить цикл. Новое значение “b” ещё скрыто в буфере записи CPU 0</li>
<li>8. CPU 1 получает сообщение “read invalidate” и предает кэш-линию с “a” процессору 0, инвалидируя свою кэш-линию</li>
<li>9. CPU 0 получает кэш-линию с “a” и выполняет ранее буферизованную запись, переводя свою кэш-линию с “a” в состояние “modified”</li>
<li>10. Так как запись “a” – единственный помеченный (marked) вызовом <code>smp_mb()</code> элемент, CPU 0 может также выполнить запись “b”, но кэш-линию с “b” находится в состоянии “shared”</li>
<li>11. Поэтому CPU 0 посылает сообщение “invalidate” процессору 1</li>
<li>12. CPU 1 получает сигнал “invalidate”, инвалидирует кэш-линию с “b” в своем кэше и шлет сигнал “acknowledgment” процессору 0</li>
<li>13. CPU 1 выполняет <code>while (b == 0) continue</code>, но кэш-линии с “b” нет в кэше, поэтому он передает сообщение “read” процессору 0</li>
<li>14. CPU 0 получает сообщение “acknowledgment” и переводит кэш-линию с “b” в состояние “exclusive”, затем сохраняет “b” в кэше</li>
<li>15. CPU 0 получает сигнал “read” и передает кэш-линию с “b” 
процессору 1. Попутно кэш-линия с “b” переводится в состояние “shared”</li>
<li>16. CPU 1 получает кэш-линию с “b” и записывает её в свой кэш</li>
<li>17. CPU 1 теперь может завершить выполнение <code>while (b == 0) continue</code> и продолжить далее</li>
<li>18. CPU 1 выполняет <code>assert(a == 1)</code>, но кэш-линии с “a” 
нет в его кэше. Как только он получит значение “a” от CPU 0, он сможет 
продолжить выполнение. Значение “a” будет самым свежим и <code>assert</code> не сработает</li>
</ul><br>
</div></div><p>
Как видим, даже интуитивно простые вещи приводят к множеству сложных шагов в кремнии.</p><h2>Нежелательные простои при последовательности записей</h2><p>
К сожалению, каждый буфер записи должен быть относительно маленьким. Это
 значит, что если CPU выполняет большую последовательность записей, он 
полностью заполняет свой store buffer (например, если каждая запись 
приводит к промаху). В этом случае CPU должен ждать, пока завершаться 
все инвалидации, чтобы затем он смог сбросить свой буфер в кэш и 
продолжить выполнение. Такая же ситуация может возникнуть сразу после 
барьера памяти, когда <i>все</i> последующие инструкции записи должны 
ждать завершения инвалидаций, вне зависимости от того, приводят ли эти 
записи к промахам кэша или нет. <br>
Такая ситуация может быть разрулена, если сообщения “invalidate 
acknowledge” будут обрабатываться быстрее. Один из путей достижения 
этого – ввести для каждого CPU очередь сообщений “invalidate”, или <i>invalidate queue</i>.</p><h3>Invalidate queue</h3><p>
Одной из причин, почему сообщения подтверждения инвалидаций (invalidate 
acknowledge) так тормозят, является то, что CPU должен быть уверен, что 
соответствующая кэш-линия действительно инвалидирована. Такая 
инвалидация может быть довольно долгой, если кэш занят, например, если 
процессор интенсивно читает/пишет данные, которые все находятся в кэше. К
 тому же, в короткий интервал времени возникает целый поток сообщений 
инвалидации, CPU может не справляться с ними, что приводит к простою 
остальных CPU. <br>
Однако CPU не обязательно инвалидировать кэш-линию перед посылкой 
подтверждения. Он может поместить invalidate-сообщение в очередь, 
конечно, с полным пониманием того, что это сообщение будет обработано 
прежде, чем процессор пошлет другие сообщения, касающиеся этой линии 
кэша.</p><p>

<img data-src="https://habrastorage.org/getpro/habr/post_images/71e/1ea/9b4/71e1ea9b425a25b13e10adff90fd733e.png" src="Lock-free%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D0%BE%D1%82%D0%BA%D1%83%D0%B4%D0%B0%20%D0%BF%D0%BE%D1%88%D0%BB%D0%B8%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%B1%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D1%8B%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_files/71e1ea9b425a25b13e10adff90fd733e.png"></p><h3>Invalidate Queues и подтверждения инвалидции</h3><p>
Рисунок справа показывает систему с очередью инвалидаций (invalidate 
queue). Процессор с invalidate queue может подтверждать 
invalidate-сообщения сразу, как только они будут появляться в очереди, 
вместо того, чтобы ждать, когда же кэш-линия инвалидируется. Разумеется,
 CPU должен согласовываться со своей очередью, когда он сам готовится 
послать invalidate-сообщение: если очередь уже содержит запись об 
инвалидации этой кэш-линии, процессор не может сразу посылать свое 
invalidate-сообщение. Вместо этого он должен ждать, пока не обработается
 соответствующая запись из очереди.<br>
Помещение элемента в invalidate queue – это по сути обещание процессора 
обработать данное invalidate-сообщение перед тем, как отправлять любой 
сигнал протокола MESI, относящийся к данной кэш-линии. <br>
Однако буферизация invalidate-сигналов приводит к дополнительной 
возможности нарушить порядок операций с памятью, что описано далее.</p><h3>Invalidate queues и барьеры памяти</h3><p>
Предположим, процессоры помещают invalidate-запросы в очередь и отвечают
 немедленно. Такой подход минимизирует задержку инвалидации кэша, но 
может нарушить барьер памяти, что мы увидим в следующем примере.<br>
Пусть переменные “a” и “b” изначально равны нулю и “a” находится в кэшах
 обоих процессоров в состоянии “shared” (то есть read-only), а “b” 
находится во владении CPU 0 (то есть линия кэша в состоянии “exclusive” 
или “modified). Предположим, CPU 0 выполняет <code>foo()</code>, а CPU 1 — <code>bar()</code>:</p><pre><code><span>1</span>	<span>void</span> <span>foo()</span>
<span>2</span>	<span>{</span>
<span>3</span>		<span>a</span> <span>=</span> <span>1</span><span>;</span>
<span>4</span>		<span>smp_mb();</span>
<span>5</span>		<span>b</span> <span>=</span> <span>1</span><span>;</span>
<span>6</span>	<span>}</span>
<span>7</span>
<span>8</span>	<span>void</span> <span>bar()</span>
<span>9</span>	<span>{</span>
<span>10</span>		<span>while</span> <span>(b</span> <span>==</span> <span>0</span><span>)</span> <span>continue;</span>
<span>11</span>		<span>assert(a</span> <span>==</span> <span>1</span><span>);</span>
<span>12</span>	<span>}</span>
</code></pre><p>
Последовательность операций может быть такой:</p><ul>
<li>1. CPU 0 выполняет <code>a=1</code>. Соответствующая кэш-линия 
является read-only в кэше CPU 0, поэтому процессор помещает новое 
значение “a” в свой store buffer и посылает сообщение “invalidate”, 
чтобы CPU 1 сбросил свою кэш-линию с “a”</li>
<li>2. CPU 1 выполняет <code>while(b == 0) continue</code>, но “b” отсутствует в его кэше. Поэтому он посылает сообщение “read”</li>
<li>3. CPU 1 получает “invalidate” от CPU 0, сохранят его в свое invalidate-очереди и немедленно отвечает</li>
<li>4. CPU 0 получает ответ от CPU 1, поэтому он волен выполнить <code>smp_mb()</code> (строка 4) и поместить новое значение “a” из своего буфера записи в кэш</li>
<li>5. CPU 0 выполняет <code>b=1</code>. Он уже владеет кэш-линией с “b”, так что он просто сохраняет новое значение “b” в своем кэше</li>
<li>6. CPU 0 получает “read”-сигнал и передает кэш-линию с новым значением “b” процессору 1, заодно помечая эту линию как “shared”</li>
<li>7. CPU 1 получает кэш-линию с “b” и помещает её в свой кэш</li>
<li>8. Теперь CPU 1 может завершить <code>while(b == 0) continue</code> и перейти к следующей строке программы</li>
<li>9. CPU 1 выполняет <code>assert(a == 1)</code>. Так как в его кэше находится старое значение “a”, <code>assert</code> срабатывает и выкидывает исключение</li>
<li>Несмотря на исключение, CPU 1 выполняет помещенное в очередь “invalidate”-сообщение и с опозданием инвалидирует кэш-линию “a”</li>
</ul><br>
<div><p><b>Вопрос-ответ</b></p><p><i>Почему на шаге 1 посылается 
сообщение “invalidate”, а не “read invalidate”? Неужели процессору не 
нужны другие значения, находящиеся в той же кэш-линии?</i><br>
У CPU 0 уже есть все эти значения, так как они находятся в разделяемой 
(shared) read-only кэш-линии вместе с “a”. Поэтому всё, что требуется 
CPU 0, это оповестить другие процессоры, что им следует уничтожить свои 
копии данной кэш-линии. Для этого достаточно сообщения “invalidate”<br>
</p></div><p>
Итак, в повышении быстродействия ответов на инвалидацию мало пользы, 
если это приводит к игнорированию барьера памяти. Поэтому барьеры памяти
 должны взаимодействовать с invalidate queue: когда процессор выполняет 
барьер памяти, он должен помечать все элементы в своей 
invalidate-очереди и притормозить все последующие чтения до тех пор, 
пока invalidate-очередь не будет им полностью обработана. </p><h2>Барьеры чтения и записи</h2><p>
В предыдущих главах барьеры памяти применялись для отметки элементов в 
store buffer и invalidate queue. Но в последнем примере нет причин для 
того, чтобы <code>foo()</code> взаимодействовал с invalidate-очередью (так как нет чтения), равно как и нет причин для того, чтобы <code>bar()</code> взаимодействовал с буфером записи (так как нет записи).<br>
Многие архитектуры предоставляют более слабые (и, как следствие, более 
быстрые) барьеры памяти, позволяющие упорядочить только чтение или 
только запись. Грубо говоря, барьер чтения (read memory barrier) 
взаимодействует только с invalidate queue (помечает её элементы, то есть
 наводит некоторый порядок в очереди), а барьер записи (write memory 
barrier) – только со store buffer (также помечает его элементы, наводит 
порядок в буфере). Полный барьер взаимодействует и с тем, и с другим.<br>
Эффект этих полубарьеров таков: барьер чтения упорядочивает только 
чтения (loads) для процессора, который выполняет барьер. Все чтения 
перед барьером полностью завершаются, и только тогда начинают 
выполняться чтения после барьера. Аналогично, барьер записи 
упорядочивает только запись (stores) для своего процессора: все записи 
до барьера завершаются, и только потом начинают выполняться записи 
(stores) после барьера. Полный барьер упорядочивает чтения и записи, но 
опять, — только для процессора, выполняющего этот барьер.<br>
Если мы обновим наш пример так, что <code>foo</code> и <code>bar</code> будут использовать барьеры чтения/записи, мы получим следующее:</p><pre><code><span>1</span>	<span>void</span> <span>foo()</span>
<span>2</span>	<span>{</span>
<span>3</span>		<span>a</span> <span>=</span> <span>1</span><span>;</span>
<span>4</span>		<span>smp_wmb();</span>	<span>//</span> <span>барьер</span> <span>записи</span>
<span>5</span>		<span>b</span> <span>=</span> <span>1</span><span>;</span>
<span>6</span>	<span>}</span>
<span>7</span>
<span>8</span>	<span>void</span> <span>bar()</span>
<span>9</span>	<span>{</span>
<span>10</span>		<span>while</span> <span>(b</span> <span>==</span> <span>0</span><span>)</span> <span>continue;</span>
<span>11</span>		<span>smp_rmb();</span> <span>//</span> <span>барьер</span> <span>чтения</span>
<span>11</span>		<span>assert(a</span> <span>==</span> <span>1</span><span>);</span>
<span>12</span>	<span>}</span>
</code></pre><p>
Некоторые архитектуры имеют даже больший набор разнообразных барьеров, 
но и понимания рассмотренных трех вариантов достаточно для введения в 
теорию барьеров памяти.</p><p>

<img src="Lock-free%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D0%BE%D1%82%D0%BA%D1%83%D0%B4%D0%B0%20%D0%BF%D0%BE%D1%88%D0%BB%D0%B8%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%B1%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D1%8B%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_files/1a2b44961990fa12e41da5013b62428d.jpg" data-src="https://habrastorage.org/getpro/habr/post_images/1a2/b44/961/1a2b44961990fa12e41da5013b62428d.jpg"></p><h2>Послесловие переводчика</h2><p>
На этом я завершаю перевод. Далее в оригинале ведется краткий обзор тех 
барьеров, которые предоставляют современные архитектуры. Интересующихся 
отсылаю к <a href="http://irl.cs.ucla.edu/~yingdi/web/paperreading/whymb.2010.06.07c.pdf">оригиналу</a>, — по объему там осталось примерно столько же.</p><p>

Попробуем подвести итоги. <br>
Итак, мы имеем две операции взаимодействия процессора с кэшем/памятью – 
чтение (load) и запись (store). Две операции дают нам в совокупности 
четыре разных барьера памяти:</p><pre><code>op1;	<span>// store или load</span>
barrier ;	<span>// memory fence</span>
op2;	<span>// store или load</span>
</code></pre><br>
<ul>
<li><b>Load/Load</b> – упорядочивает предыдущие load-инструкции с 
последующими. Как мы видели, этот барьер “наводит порядок” в invalidate 
queue: либо целиком обрабатывает эту очередь, либо проставляет в ней 
некоторые метки, задающие порядок обработки очереди в будущем. 
Относительно легкий барьер</li>
<li><b>Store/Store</b> – упорядочивает предыдущие store-инструкции с 
последующими. Воздействует на store buffer: либо целиком обрабатывает 
накопившийся буфер (что довольно накладно – операции записи всегда 
тяжелы для современных процессоров), либо, более вероятно, как-то 
помечает текущее содержимое store buffer, то есть опять-таки наводит в 
нем некоторый порядок его последующей обработки. В этом случае 
относительно легкий барьер</li>
<li><b>Load/Store</b> – упорядочивает предыдущие load-инструкции с 
последующими store. На что он может воздействовать? Думаю, препятствует 
спекулятивной записи. Похоже, также является довольно легким барьером</li>
<li><b>Store/Load</b> – упорядочивает предыдущие store-инструкции с 
последующими load. У нас store-инструкции попадают в store buffer. То 
есть этот барьер должен упорядочить store buffer, — просто проставить в 
нем некие метки? Нет, похоже, этого недостаточно. Ведь существует еще 
спекулятивное чтение, — этот барьер и его должен ограничить. На 
основании того, что мне известно о современных архитектурах, могу 
сделать вывод, что этот барьер приводит к полной обработке store buffer,
 что является довольно тяжелым действием. Итог: это самый тяжелый барьер
 из всех рассмотренных</li>
</ul><br>
<div><p><b>Поздравляю, мы вывели барьеры памяти архитектуры Sparc!</b></p><div><p><img data-src="https://habrastorage.org/getpro/habr/post_images/ad4/0b7/07a/ad40b707aff57f6c540d0c4d1daa89a1.png" src="Lock-free%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D0%BE%D1%82%D0%BA%D1%83%D0%B4%D0%B0%20%D0%BF%D0%BE%D1%88%D0%BB%D0%B8%20%D0%B1%D1%8B%D1%82%D1%8C%20%D0%B1%D0%B0%D1%80%D1%8C%D0%B5%D1%80%D1%8B%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8_files/ad40b707aff57f6c540d0c4d1daa89a1.png"><br>
Архитектура Sparc (в самом расслабленном своем режиме RMO – Relaxed Memory Ordering) имеет инструкцию <code>membar</code>,
 в качестве параметров которой передается всегда константа — набор 
битовых флагов, которые можно комбинировать битовым ИЛИ. Мнемоники этих 
флагов — <code>#LoadLoad</code>, <code>#LoadStore</code>, <code>#StoreStore</code>, <code>#StoreLoad</code> (остальные специфические флаги я рассматривать не буду, — они не относятся к прикладному программированию). Инструкция <code>membar</code> должна располагаться в коде между соответствующими операциями, для которых она является барьером:</p><ul>
<li><code> Load1; membar #LoadLoad; Load2 </code></li>
<li><code> Load; membar #LoadStore; Store </code></li>
<li><code> Store; membar #StoreLoad; Load </code></li>
<li><code> Store1; membar #StoreStore; Store2 </code></li>
</ul><p>
Например, полный барьер памяти в Sparc будет выглядеть на ассемблере так:</p><pre><code>membar    <span>#LoadLoad</span>|<span>#LoadStore</span>|<span>#StoreStore</span>|<span>#StoreLoad</span>
</code></pre><p>
 В принципе, все флаги и их комбинации представляют довольно легкие барьеры, кроме одного — <code>#StoreLoad</code>. И это не особенность архитектуры Sparc, а фактически свойство всех современных weakly-ordered процессоров. <br>
</p></div></div><h3>Далее</h3><p>
Итак, мы рассмотрели, откуда взялись барьеры памяти. Узнали, что они 
есть необходимое зло. Мы даже попробовали их как-то расставить в коде. </p><div><p><b>Вытесняющий планировщик и барьеры памяти</b></p><p>Стоит заметить, что барьеры памяти — это именно <i>отдельные</i>
 ассемблерные инструкции практически у всех современных архитектур 
(особняком стоит, пожалуй, только Intel Itanium – в нем барьер может 
являться частью load/store/RMW-инструкции). Корректная расстановка 
барьеров критически важна в lock-free алгоритмах. Но современные 
операционные системы в подавляющем большинстве реализуют вытесняющую 
модель управления процессами/потоками. То есть потоку отводится квант 
времени, по истечении которого он вытесняется другим потоком. Вытеснение
 (переключение контекста) может произойти и непосредственно перед 
инструкцией барьера памяти. Получается, что все наши старания насмарку –
 мы выполнили критическую атомарную операцию, а барьера после неё нет? <br>
На самом деле барьер есть. Код переключения контекста имеет одной из своих первых инструкций как раз <i>полный</i>
 барьер памяти или что-то подобное, зачастую более тяжеловесное, чем нам
 нужно. Поэтому наш lock-free алгоритм будет работать правильно, если, 
конечно же, мы сами где-то не накосячим.<br>
</p></div><p>
Рассмотренный подход к расстановке барьеров памяти я бы назвал 
read/wrire-подходом. В ходе разработки стандарта C++11 read/write-подход
 к проблемам упорядочения доступа к памяти был признан слишком 
привязанным к архитектуре и была разработана <i>acquire/release семантика</i>,
 легшая в основу стандарта. Как не раз было сказано в статье, барьеры 
памяти прямо влияют только на процессор, выполняющий барьер, и только 
опосредованно (через протокол MESI) — на другие процессоры. Модель 
acquire/release поступает по-другому, — в ней постулируется, как должны <i>взаимодействовать</i>
 разные параллельные потоки (то есть процессоры/ядра), и практически 
ничего не говорится, как этого достичь. На самом деле, реализация этой 
модели — это применение тех или иных барьеров памяти.<br>
О модели памяти C++11 я собираюсь поговорить в следующей статье <i>Основ</i>.</p><div><p><b>Lock-free структуры данных</b></p></div></div></div></div>
    </div>

    <div>
      <div class="reader-message"></div>
    </div>
    <div aria-owns="toolbar"></div>
  </div>

  <div id="pocket-cta-container" hidden="">
    <div class="pocket-cta-inner" id="pocket-cta-only">
      <div class="pocket-cta">
        <header class="pocket-cta-header">Save anything from across the web in Pocket, your personal library.</header>
        <p class="pocket-cta-subhead">As part of the Firefox family, 
Pocket provides a quiet, calm space that’s perfect for reading. It 
strips away all the distractions of the internet so you can really 
focus.</p>
        <a href="https://getpocket.com/signup?utm_source=firefox_reader&amp;utm_medium=variant_cta_only" class="pocket-btn pocket-sign-up"><strong>Sign up</strong> - it’s free</a>
        <a href="https://getpocket.com/explore?utm_source=firefox_reader&amp;utm_medium=variant_cta_only" class="pocket-btn pocket-discover-more"><strong>Discover more</strong></a>
      </div>
      <button class="pocket-dismiss-cta" title="Dismiss"></button>
    </div>

    <div class="pocket-cta-inner" id="pocket-cta-and-recs">
      <div class="pocket-recs-top">
        <div class="col">
          <header class="pocket-cta-header">Discover the most thought-provoking stories out there, curated by Pocket.</header>
          <p class="pocket-cta-subhead">As part of the Firefox family, 
Pocket surfaces the best articles out there—new perspectives, intriguing
 deep-dives, timeless classics—and we do this with the same dedication 
to privacy you’ve come to expect from Firefox and Mozilla. </p>
        </div>
        <div class="col">
          <button class="pocket-collapse-recs"></button>
        </div>
      </div>

      <div class="pocket-recs"></div>

      <div class="pocket-sign-up-wrapper">
        <a href="https://getpocket.com/explore?utm_source=firefox_reader&amp;utm_medium=variant_cta_plus_recs" class="pocket-btn pocket-sign-up"><strong>Discover more</strong></a>
      </div>
    </div>
  </div>



</body></html>