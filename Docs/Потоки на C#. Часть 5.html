<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru-ru" lang="ru-ru"><head>
<!-- Global site tag (gtag.js) - Google Analytics -->


  
  <!-- base href="http://microsin.net/programming/pc/threading-in-csharp-part-5-parallel-programming.html" -->
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="robots" content="index, follow">
  <meta name="keywords" content="C#, threading">
  
  <meta name="author" content="microsin">
  <meta name="description" content="Описание принципов организации параллельных вычислений на многоядерных процессорах.">
  
  <title>Потоки на C#. Часть 5: параллельное программирование | pc | programming</title>
  <link href="http://microsin.net/component/option,com_jcomments/format,raw/object_group,com_content/object_id,2256/task,rss/" rel="alternate" type="application/rss+xml" title="Потоки на C#. Часть 5: параллельное программирование">
  <link rel="stylesheet" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/style.css" type="text/css">
  <link rel="stylesheet" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/spoiler.css" type="text/css">
  <link rel="stylesheet" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/acesearch.css" type="text/css">
  <style type="text/css">
    <!--

    .sp-head-click a{font-size: 11px; font-style: normal; color: #000000 !important; }
	.sp-head{border: 0px #ccc solid; font-weight: bold;
            -webkit-border-radius: 8px;
            -moz-border-radius: 8px;
            -khtml-border-radius: 8px;
            border-radius: 8px;
            width: 85%;
            background-color: #f0f0f0;
            text-shadow: 0 -1px 1px rgba(0,0,0,0.25);
            box-shadow: 0 0 5px rgba(0,0,0,0.6);
            -moz-box-shadow: 0 0 5px rgba(0,0,0,0.6);
	        -webkit-box-shadow: 0 0 5px rgba(0,0,0,0.6);
	        }
	.sp-body{font-size: 11px; font-weight: normal; background: #FFFDDD; border: 1px #ccc solid; 
	-webkit-border-radius: 7px;
	-moz-border-radius: 7px;
	-khtml-border-radius: 7px;
	border-radius: 7px;
	width: 95%;
	font-style: italic;
	padding: 10px}	
	
    -->
  </style>
  
  
  
  
  
  
  
  
  
  
  
  <link rel="stylesheet" type="text/css" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/style_002.css">
<link rel="stylesheet" type="text/css" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/comment_style.css">



<link rel="stylesheet" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/system.css" type="text/css">
<link rel="stylesheet" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/general.css" type="text/css">
<link rel="stylesheet" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/template_css.css" type="text/css">
<!-- <link rel="shortcut"   href="/templates/microsin/images/favicon16x16-8b.gif" type="image/x-icon"/> -->
<link rel="shortcut icon" href="http://microsin.net/templates/microsin/images/favicon16x16-8b.gif">
<meta http-equiv="Content-Language" content="en"><style type="text/css" id="ya_share_style">.b-share-popup-wrap{z-index:1073741823;position:absolute;width:500px}.b-share-popup{position:absolute;z-index:1073741823;border:1px solid #888;background:#FFF;color:#000}.b-share-popup-wrap .b-share-popup_down{top:0}.b-share-popup-wrap .b-share-popup_up{bottom:0}.b-share-popup-wrap_state_hidden{position:absolute!important;top:-9999px!important;right:auto!important;bottom:auto!important;left:-9999px!important;visibility:hidden!important}.b-share-popup,x:nth-child(1){border:0;padding:1px!important}@media all and (resolution=0){.b-share-popup,x:nth-child(1),x:-o-prefocus{padding:0!important;border:1px solid #888}}.b-share-popup__i{display:-moz-inline-box;display:inline-block;padding:5px 0!important;overflow:hidden;vertical-align:top;white-space:nowrap;visibility:visible;background:#FFF;-webkit-box-shadow:0 2px 9px rgba(0,0,0,.6);-moz-box-shadow:0 2px 9px rgba(0,0,0,.6);box-shadow:0 2px 9px rgba(0,0,0,.6)}.b-share-popup__item{font:1em/1.25em Arial,sans-serif;display:block;padding:5px 15px!important;white-space:nowrap;background:#FFF}.b-share-popup__item,a.b-share-popup__item:link,a.b-share-popup__item:visited{text-decoration:none!important;border:0!important}a.b-share-popup__item{cursor:pointer}a.b-share-popup__item .b-share-popup__item__text{display:inline;text-decoration:underline;color:#1A3DC1}a.b-share-popup__item:hover{word-spacing:0}a.b-share-popup__item:hover .b-share-popup__item__text{color:red;cursor:pointer}.b-share-popup__icon{display:-moz-inline-box;display:inline-block;margin:-3px 0 0;padding:0 5px 0 0!important;vertical-align:middle}.b-share-popup__icon_input{width:21px;height:16px;margin-top:-6px;padding:0!important}.b-share-popup__icon__input{margin-right:0;margin-left:2px;vertical-align:top}.b-share-popup__spacer{display:block;padding-top:10px!important}.b-share-popup__header{font:86%/1em Verdana,sans-serif;display:block;padding:10px 15px 5px!important;color:#999}.b-share-popup__header_first{padding-top:5px!important}.b-share-popup__input{font:86%/1em Verdana,sans-serif;display:block;padding:5px 15px!important;color:#999;text-align:left}.b-share-popup__input__input{font:1em/1em Verdana,sans-serif;display:block;width:10px;margin:5px 0 0;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;resize:none;text-align:left;direction:ltr}.b-share-popup_down .b-share-popup_with-link .b-share-popup__input_link{position:absolute;top:5px;right:0;left:0}.b-share-popup_up .b-share-popup_with-link .b-share-popup__input_link{position:absolute;right:0;bottom:5px;left:0}.b-share-popup_down .b-share-popup_with-link{padding-top:55px!important}.b-share-popup_up .b-share-popup_with-link{padding-bottom:55px!important}.b-share-popup_down .b-share-popup_expandable .b-share-popup__main{padding-bottom:25px!important}.b-share-popup_up .b-share-popup_expandable .b-share-popup__main{padding-top:25px!important}.b-share-popup_down .b-share-popup_yandexed{padding-bottom:10px!important}.b-share-popup_up .b-share-popup_yandexed{padding-top:10px!important}.b-share-popup__yandex{position:absolute;right:4px;bottom:2px;font:78.125%/1em Verdana,sans-serif;padding:3px!important;background:0 0}a.b-share-popup__yandex:link,a.b-share-popup__yandex:visited{color:#C6C5C5;text-decoration:none}a.b-share-popup__yandex:link:hover,a.b-share-popup__yandex:visited:hover{color:red;text-decoration:underline}.b-share-popup_up .b-share-popup__yandex{top:2px;bottom:auto}.b-share-popup_expandable .b-share-popup__yandex{right:auto;left:4px}.b-share-popup_to-right .b-share-popup_expandable .b-share-popup__yandex{right:4px;left:auto}.b-share-popup__expander .b-share-popup__item{position:absolute;bottom:5px;font:86%/1em Verdana,sans-serif;margin:10px 0 0;padding:5px 10px!important;cursor:pointer;color:#999;background:0 0}.b-share-popup_to-right,.b-share-popup_to-right .b-share-popup__expander{direction:rtl}.b-share-popup_to-right .b-share-popup__expander .b-share-popup__icon{padding:0 0 0 5px!important}.b-share-popup_up .b-share-popup__expander .b-share-popup__item{top:-5px;bottom:auto}.b-share-popup__expander .b-share-popup__item:hover .b-share-popup__item__text{text-decoration:underline}.b-share-popup__expander .b-ico_action_rarr,.b-share-popup_to-right .b-share-popup__expander .b-ico_action_larr,.b-share-popup_full .b-share-popup__expander .b-ico_action_larr,.b-share-popup_to-right .b-share-popup_full .b-share-popup__expander .b-ico_action_rarr,.b-share-popup__expander .b-share-popup__item__text_collapse,.b-share-popup_full .b-share-popup__item__text_expand{display:none}.b-share-popup_to-right .b-share-popup__expander .b-ico_action_rarr,.b-share-popup_full .b-share-popup__item__text_collapse,.b-share-popup_full .b-share-popup__expander .b-ico_action_rarr,.b-share-popup_to-right .b-share-popup_full .b-share-popup__expander .b-ico_action_larr{display:inline}.b-ico_action_rarr,.b-ico_action_larr{width:8px;height:7px;border:0}.b-share-popup__main,.b-share-popup__extra{direction:ltr;vertical-align:bottom;text-align:left}.b-share-popup_down .b-share-popup__main,.b-share-popup_down .b-share-popup__extra{vertical-align:top}.b-share-popup__main{display:-moz-inline-stack;display:inline-block}.b-share-popup__extra{display:none;margin:0 -10px 0 0}.b-share-popup_full .b-share-popup__extra{display:-moz-inline-stack;display:inline-block}.b-share-popup_to-right .b-share-popup__extra{margin:0 0 0 -10px}.b-share-popup__tail{position:absolute;width:21px;height:10px;margin:0 0 0 -11px}.b-share-popup_down .b-share-popup__tail{top:-10px;background:url("//yastatic.net/share/static/b-share-popup_down__tail.gif") 0 0 no-repeat}.b-share-popup_up .b-share-popup__tail{bottom:-10px;background:url("//yastatic.net/share/static/b-share-popup_up__tail.gif") 0 0 no-repeat}.b-share-popup_down .b-share-popup__tail,x:nth-child(1){top:-9px;background-image:url("//yastatic.net/share/static/b-share-popup_down__tail.png")}.b-share-popup_up .b-share-popup__tail,x:nth-child(1){bottom:-9px;background-image:url("//yastatic.net/share/static/b-share-popup_up__tail.png")}@media all and (resolution=0){.b-share-popup_down .b-share-popup__tail,x:nth-child(1),x:-o-prefocus{top:-10px;background-image:url("//yastatic.net/share/static/b-share-popup_down__tail.gif")}.b-share-popup_up .b-share-popup__tail,x:nth-child(1),x:-o-prefocus{bottom:-10px;background-image:url("//yastatic.net/share/static/b-share-popup_up__tail.gif")}}.b-share-popup .b-share-popup_show_form_mail,.b-share-popup .b-share-popup_show_form_html{padding:0!important}.b-share-popup .b-share-popup_show_form_mail .b-share-popup__main,.b-share-popup .b-share-popup_show_form_html .b-share-popup__main,.b-share-popup .b-share-popup_show_form .b-share-popup__main,.b-share-popup .b-share-popup_show_form_mail .b-share-popup__extra,.b-share-popup .b-share-popup_show_form_html .b-share-popup__extra,.b-share-popup .b-share-popup_show_form .b-share-popup__extra{height:15px;padding:0!important;overflow:hidden;visibility:hidden}.b-share-popup_show_form_mail .b-share-popup__expander,.b-share-popup_show_form_html .b-share-popup__expander,.b-share-popup_show_form .b-share-popup__expander,.b-share-popup_show_form_mail .b-share-popup__input_link,.b-share-popup_show_form_html .b-share-popup__input_link,.b-share-popup_show_form .b-share-popup__input_link{display:none}.b-share-popup__form{position:relative;display:none;overflow:hidden;padding:5px 0 0!important;margin:0 0 -15px;white-space:normal}.b-share-popup_show_form_mail .b-share-popup__form_mail,.b-share-popup_show_form_html .b-share-popup__form_html,.b-share-popup_show_form .b-share-popup__form{display:block}.b-share-popup__form__link{padding:5px!important;margin:0 0 5px 10px;text-decoration:underline;cursor:pointer;color:#1A3DC1}.b-share-popup__form__link,.b-share-popup__form__button{font:86%/1.4545em Verdana,sans-serif;float:left;display:inline}.b-share-popup__form__button{margin:5px 0 0 15px}.b-share-popup__form__close{font:86%/1.4545em Verdana,sans-serif;float:right;display:inline;padding:5px!important;margin:0 10px 5px 0;cursor:pointer;color:#999}a.b-share-popup__form__link:hover,a.b-share-popup__form__close:hover{text-decoration:underline;color:red}.b-share-popup_font_fixed .b-share-popup__item{font-size:12.8px}.b-share-popup_font_fixed .b-share-popup__header,.b-share-popup_font_fixed .b-share-popup__input,.b-share-popup_font_fixed .b-share-popup__expander .b-share-popup__item,.b-share-popup_font_fixed .b-share-popup__form__link,.b-share-popup_font_fixed .b-share-popup__form__button,.b-share-popup_font_fixed .b-share-popup__form__close{font-size:11px}.b-share-popup_font_fixed .b-share-popup__yandex{font-size:10px}.b-share-form-button{font:86%/17px Verdana,Arial,sans-serif;display:-moz-inline-box;display:inline-block;position:relative;height:19px;margin:0 3px;padding:0 4px;cursor:default;white-space:nowrap;text-decoration:none!important;color:#000!important;border:none;outline:none;background:url("//yastatic.net/share/static/b-share-form-button.png") 0 -20px repeat-x}.b-share-form-button:link:hover,.b-share-form-button:visited:hover{color:#000!important}.b-share-form-button__before,.b-share-form-button__after{position:absolute;width:3px;height:19px;background:url("//yastatic.net/share/static/b-share-form-button.png")}.b-share-form-button__before{margin-left:-7px}.b-share-form-button__after{margin-left:4px;background-position:-3px 0}.b-share-form-button::-moz-focus-inner{border:none}button.b-share-form-button .b-share-form-button__before,button.b-share-form-button .b-share-form-button__after{margin-top:-1px}@-moz-document url-prefix(){button.b-share-form-button .b-share-form-button__after{margin-top:-2px;margin-left:6px}button.b-share-form-button .b-share-form-button__before{margin-top:-2px;margin-left:-9px}}SPAN.b-share-form-button:hover,.b-share-form-button_state_hover{background-position:0 -60px}SPAN.b-share-form-button:hover .b-share-form-button__before,.b-share-form-button_state_hover .b-share-form-button__before{background-position:0 -40px}SPAN.b-share-form-button:hover .b-share-form-button__after,.b-share-form-button_state_hover .b-share-form-button__after{background-position:-3px -40px}.b-share-form-button_state_pressed,.b-share-form-button_state_pressed .b-share-form-button_share{background-position:0 -100px!important}.b-share-form-button_state_pressed .b-share-form-button__before{background-position:0 -80px!important}.b-share-form-button_state_pressed .b-share-form-button__after{background-position:-3px -80px!important}button.b-share-form-button_state_pressed{overflow:visible}.b-share-form-button_icons{position:relative;padding:0;background-position:0 -20px!important}.b-share-form-button_icons .b-share-form-button__before{left:0;margin-left:-3px;background-position:0 0!important}.b-share-form-button_icons .b-share-form-button__after{z-index:-1;margin-left:0;background-position:-3px 0!important}.b-share-form-button_icons .b-share__handle{padding:2px!important}.b-share-form-button_icons .b-share__handle_more{position:relative;padding-right:6px!important;margin-right:-4px}.b-share-form-button_icons .b-share-icon{opacity:.5;background-image:url("//yastatic.net/share/static/b-share-icon_size_14.png")}.b-share-form-button_icons A.b-share__handle:hover .b-share-icon{opacity:1}.b-share{font:86%/1.4545em Arial,sans-serif;display:-moz-inline-box;display:inline-block;padding:1px 3px 1px 4px!important;vertical-align:middle}.b-share .b-share-form-button{font-size:1em}.b-share__text .b-share-icon{margin:0 5px 0 0;border:none}.b-share__text{margin-right:5px}.b-share__handle{float:left;height:16px;padding:5px 3px 5px 2px!important;cursor:pointer;text-align:left;text-decoration:none!important}.b-share__handle_cursor_default{cursor:default}.b-share__handle .b-share-form-button{margin-top:-2px}.b-share__hr{display:none;float:left;width:1px;height:26px;margin:0 3px 0 2px}a.b-share__handle:hover .b-share__text{text-decoration:underline;color:red}.b-share_bordered{padding:0 2px 0 3px!important;border:1px solid #E4E4E4;-moz-border-radius:5px;-webkit-border-radius:5px;border-radius:5px}.b-share_bordered .b-share__hr{display:inline;background:#E4E4E4}.b-share_link{margin:-8px 0}a.b-share_link{margin:0}.b-share_link .b-share__text{text-decoration:underline;color:#1A3DC1}.b-share-form-button_share{padding-left:26px!important;vertical-align:top}.b-share-form-button_share .b-share-form-button__before{margin-left:-29px}.b-share-form-button_share .b-share-form-button__icon{position:absolute;width:20px;height:17px;margin:1px 0 0 -23px;background:url("//yastatic.net/share/static/b-share-form-button_share__icon.png") 0 0 no-repeat}.b-share-pseudo-link{border-bottom:1px dotted;cursor:pointer;text-decoration:none!important}.b-share_font_fixed{font-size:11px}.b-share__handle_more{font-size:9px;margin-top:-1px;color:#7B7B7B}A.b-share__handle_more:hover{color:#000}.b-share__group{float:left}.b-share-icon{float:left;display:inline;overflow:hidden;width:16px;height:16px;padding:0!important;vertical-align:top;border:0;background:url("//yastatic.net/share/static/b-share-icon.png") 0 99px no-repeat}.b-share-icon_vkontakte,.b-share-icon_custom{background-position:0 0}.b-share-icon_yaru,.b-share-icon_yaru_photo,.b-share-icon_yaru_wishlist{background-position:0 -17px}.b-share-icon_lj{background-position:0 -34px}.b-share-icon_twitter{background-position:0 -51px}.b-share-icon_facebook{background-position:0 -68px}.b-share-icon_moimir{background-position:0 -85px}.b-share-icon_friendfeed{background-position:0 -102px}.b-share-icon_mail{background-position:0 -119px}.b-share-icon_html{background-position:0 -136px}.b-share-icon_postcard{background-position:0 -153px}.b-share-icon_odnoklassniki{background-position:0 -170px}.b-share-icon_blogger{background-position:0 -187px}.b-share-icon_delicious{background-position:0 -221px}.b-share-icon_gbuzz{background-position:0 -238px}.b-share-icon_linkedin{background-position:0 -255px}.b-share-icon_myspace{background-position:0 -272px}.b-share-icon_evernote{background-position:0 -289px}.b-share-icon_digg{background-position:0 -306px}.b-share-icon_juick{background-position:0 -324px}.b-share-icon_moikrug{background-position:0 -341px}.b-share-icon_yazakladki{background-position:0 -358px}.b-share-icon_liveinternet{background-position:0 -375px}.b-share-icon_tutby{background-position:0 -392px}.b-share-icon_diary{background-position:0 -409px}.b-share-icon_gplus{background-position:0 -426px}.b-share-icon_pocket{background-position:0 -443px}.b-share-icon_surfingbird{background-position:0 -460px}.b-share-icon_pinterest{background-position:0 -477px}.b-share-icon_renren{background-position:0 0}.b-share-icon_renren,.b-share-icon_sina_weibo{background:url("//yastatic.net/share/static/b-share-icon__china.png") no-repeat}.b-share-icon_sina_weibo{background-position:-18px 0}.b-share-icon_qzone{background-position:-36px 0}.b-share-icon_qzone,.b-share-icon_tencent_weibo{background:url("//yastatic.net/share/static/b-share-icon__china.png") no-repeat}.b-share-icon_tencent_weibo{background-position:-54px 0}.b-share_theme_dark .b-share-icon{background:url("//yastatic.net/share/static/b-share-icons__theme_dark.png") 99px 0 no-repeat}.b-share_theme_dark .b-share-icon_odnoklassniki{background-position:-4px -3px}.b-share_theme_dark .b-share-icon_vkontakte{background-position:-24px -3px}.b-share_theme_dark .b-share-icon_twitter{background-position:-44px -3px}.b-share_theme_dark .b-share-icon_facebook{background-position:-64px -3px}.b-share_theme_dark .b-share-icon_lj{background-position:-85px -3px}.b-share_theme_dark .b-share-icon_yaru{background-position:-105px -3px}.b-share_theme_dark .b-share-popup .b-share-icon_odnoklassniki,.b-share_theme_dark .b-share-icon_odnoklassniki:hover{background-position:-4px -28px}.b-share_theme_dark .b-share-popup .b-share-icon_vkontakte,.b-share_theme_dark .b-share-icon_vkontakte:hover{background-position:-24px -28px}.b-share_theme_dark .b-share-popup .b-share-icon_twitter,.b-share_theme_dark .b-share-icon_twitter:hover{background-position:-44px -28px}.b-share_theme_dark .b-share-popup .b-share-icon_facebook,.b-share_theme_dark .b-share-icon_facebook:hover{background-position:-64px -28px}.b-share_theme_dark .b-share-popup .b-share-icon_lj,.b-share_theme_dark .b-share-icon_lj:hover{background-position:-85px -28px}.b-share_theme_dark .b-share-popup .b-share-icon_yaru,.b-share_theme_dark .b-share-icon_yaru:hover{background-position:-105px -28px}.b-share_theme_dark .b-share-form-button_share .b-share-form-button__icon{background-image:url("//yastatic.net/share/static/b-share-form-button_share__icon_dark.png")}.b-share_theme_dark .b-share-form-button{color:#fff!important;opacity:.8}.b-share_theme_dark .b-share__handle:hover .b-share-form-button,.b-share_theme_dark .b-share-form-button:hover{opacity:1;cursor:pointer}.b-share_theme_dark .b-share-form-button,.b-share_theme_dark .b-share-form-button__before,.b-share_theme_dark .b-share-form-button__after{background:0 0}.b-share_theme_dark .b-share-popup__i{background-color:#333;border-radius:10px;-webkit-box-shadow:0 2px 9px rgba(255,255,255,.6);-moz-box-shadow:0 2px 9px rgba(255,255,255,.6);box-shadow:0 2px 9px rgba(255,255,255,.6)}.b-share_theme_dark .b-share__text{color:#AAA}.b-share_theme_dark .b-share-popup{color:#AAA;border-radius:10px;background-color:#333;background-color:rgba(50,50,50,.3)}.b-share_theme_dark .b-share-popup__item{background:0 0;color:#ccc}.b-share_theme_dark .b-share-popup .b-share-popup__item__text{color:#ccc}.b-share_theme_counter .b-share{display:inline-block;vertical-align:middle;white-space:nowrap}.b-share-counter{font:14px Arial,sans-serif;line-height:18px;display:none;float:left;margin:3px 6px 3px 3px;color:#fff}.b-share_theme_counter .b-share_type_small .b-share-counter{font-size:11px;line-height:14px;margin:2px 6px 2px 1px}.b-share_theme_counter .b-share-btn__counter .b-share-counter{display:block}.b-share-btn__counter{text-decoration:none}.b-share_theme_counter .b-share-btn__wrap{position:relative;float:left;margin-left:5px}.b-share_theme_counter .b-share_type_small .b-share-btn__wrap{margin-left:4px}.b-share_theme_counter .b-share-btn__wrap:first-child{margin-left:0}.b-share_theme_counter .b-share__link{display:inline-block;cursor:pointer;-webkit-border-radius:3px;border-radius:3px}.b-share_theme_counter .b-share_type_small .b-share__link{-webkit-border-radius:2px;border-radius:2px}.b-share_theme_counter .b-share-icon{display:block;float:left;width:24px;height:24px;background-image:url("//yastatic.net/share/static/b-share_counter_large.png");background-position:-20px 0}.b-share_theme_counter .b-share_type_small .b-share-icon{width:18px;height:18px;background-image:url("//yastatic.net/share/static/b-share_counter_small.png")}.b-share_theme_counter .b-share-icon_facebook{background-position:0 0}.b-share_theme_counter .b-share-btn__facebook{background-color:#3c5a98}.b-share_theme_counter .b-share-btn__facebook:hover{background-color:#30487a}.b-share_theme_counter .b-share-btn__facebook:active{border-top:2px solid #24365a;background-color:#334d81}.b-share_theme_counter .b-share-icon_moimir{background-position:0 -29px}.b-share_theme_counter .b-share-btn__moimir{background-color:#226eb7}.b-share_theme_counter .b-share-btn__moimir:hover{background-color:#1b5892}.b-share_theme_counter .b-share-btn__moimir:active{border-top:2px solid #14426d;background-color:#1d5e9c}.b-share_theme_counter .b-share-icon_vkontakte{background-position:0 -58px}.b-share_theme_counter .b-share-btn__vkontakte{background-color:#48729e}.b-share_theme_counter .b-share-btn__vkontakte:hover{background-color:#3a5b7e}.b-share_theme_counter .b-share-btn__vkontakte:active{border-top:2px solid #2b445e;background-color:#3d6186}.b-share_theme_counter .b-share-icon_twitter{background-position:0 -87px}.b-share_theme_counter .b-share-btn__twitter{background-color:#00aced}.b-share_theme_counter .b-share-btn__twitter:hover{background-color:#008abe}.b-share_theme_counter .b-share-btn__twitter:active{border-top:2px solid #00668d;background-color:#0092ca}.b-share_theme_counter .b-share-icon_odnoklassniki{background-position:0 -116px}.b-share_theme_counter .b-share-btn__odnoklassniki{background-color:#ff9f4d}.b-share_theme_counter .b-share-btn__odnoklassniki:hover{background-color:#cc7f3e}.b-share_theme_counter .b-share-btn__odnoklassniki:active{border-top:2px solid #975e2e;background-color:#d98742}.b-share_theme_counter .b-share-icon_gplus{background-position:0 -145px}.b-share_theme_counter .b-share-btn__gplus{background-color:#c25234}.b-share_theme_counter .b-share-btn__gplus:hover{background-color:#9b422a}.b-share_theme_counter .b-share-btn__gplus:active{border-top:2px solid #73311f;background-color:#a5462c}.b-share_theme_counter .b-share-icon_yaru{background-position:0 -174px}.b-share_theme_counter .b-share-btn__yaru{background-color:#d83933}.b-share_theme_counter .b-share-btn__yaru:hover{background-color:#ad2e29}.b-share_theme_counter .b-share-btn__yaru:active{border-top:2px solid #80221e;background-color:#b8312b}.b-share_theme_counter .b-share-icon_pinterest{background-position:0 -203px}.b-share_theme_counter .b-share-btn__pinterest{background-color:#cd1e27}.b-share_theme_counter .b-share-btn__pinterest:hover{background-color:#a4181f}.b-share_theme_counter .b-share-btn__pinterest:active{border-top:2px solid #7b1217;background-color:#ae1921}.b-share_theme_counter .b-share__link:active{height:22px}.b-share_theme_counter .b-share_type_small .b-share__link:active{height:16px}.b-share_theme_counter .b-share__link:active .b-share-icon,.b-share_theme_counter .b-share__link:active .b-share-counter{position:relative;top:-1px}.b-share_theme_counter .b-share__link::after{position:absolute;top:0;right:0;bottom:0;left:0;content:"";background-image:url(data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)}.b-share_theme_counter .b-share__handle{height:auto;padding:0!important}</style><meta http-equiv="origin-trial" content="AxujKG9INjsZ8/gUq8+dTruNvk7RjZQ1oFhhgQbcTJKDnZfbzSTE81wvC2Hzaf3TW4avA76LTZEMdiedF1vIbA4AAABueyJvcmlnaW4iOiJodHRwczovL2ltYXNkay5nb29nbGVhcGlzLmNvbTo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2NTI3NzQ0MDAsImlzVGhpcmRQYXJ0eSI6dHJ1ZX0="><meta http-equiv="origin-trial" content="Azuce85ORtSnWe1MZDTv68qpaW3iHyfL9YbLRy0cwcCZwVnePnOmkUJlG8HGikmOwhZU22dElCcfrfX2HhrBPAkAAAB7eyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2NTI3NzQ0MDAsImlzU3ViZG9tYWluIjp0cnVlLCJpc1RoaXJkUGFydHkiOnRydWV9"><meta http-equiv="origin-trial" content="A16nvcdeoOAqrJcmjLRpl1I6f3McDD8EfofAYTt/P/H4/AWwB99nxiPp6kA0fXoiZav908Z8etuL16laFPUdfQsAAACBeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXRhZ3NlcnZpY2VzLmNvbTo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2NTI3NzQ0MDAsImlzU3ViZG9tYWluIjp0cnVlLCJpc1RoaXJkUGFydHkiOnRydWV9"><meta http-equiv="origin-trial" content="AxBHdr0J44vFBQtZUqX9sjiqf5yWZ/OcHRcRMN3H9TH+t90V/j3ENW6C8+igBZFXMJ7G3Pr8Dd13632aLng42wgAAACBeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiVHJ1c3RUb2tlbnMiLCJleHBpcnkiOjE2NTI3NzQ0MDAsImlzU3ViZG9tYWluIjp0cnVlLCJpc1RoaXJkUGFydHkiOnRydWV9"><meta http-equiv="origin-trial" content="A88BWHFjcawUfKU3lIejLoryXoyjooBXLgWmGh+hNcqMK44cugvsI5YZbNarYvi3roc1fYbHA1AVbhAtuHZflgEAAAB2eyJvcmlnaW4iOiJodHRwczovL2dvb2dsZS5jb206NDQzIiwiZmVhdHVyZSI6IlRydXN0VG9rZW5zIiwiZXhwaXJ5IjoxNjUyNzc0NDAwLCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><meta http-equiv="origin-trial" content="A8FHS1NmdCwGqD9DwOicnHHY+y27kdWfxKa0YHSGDfv0CSpDKRHTQdQmZVPDUdaFWUsxdgVxlwAd6o+dhJykPA0AAACWeyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiQ29udmVyc2lvbk1lYXN1cmVtZW50IiwiZXhwaXJ5IjoxNjQzMTU1MTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlLCJ1c2FnZSI6InN1YnNldCJ9"><meta http-equiv="origin-trial" content="A8zdXi6dr1hwXEUjQrYiyYQGlU3557y5QWDnN0Lwgj9ePt66XMEvNkVWOEOWPd7TP9sBQ25X0Q15Lr1Nn4oGFQkAAACceyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiQ29udmVyc2lvbk1lYXN1cmVtZW50IiwiZXhwaXJ5IjoxNjQzMTU1MTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlLCJ1c2FnZSI6InN1YnNldCJ9"><meta http-equiv="origin-trial" content="A4/Htern2udN9w3yJK9QgWQxQFruxOXsXL7cW60DyCl0EZFGCSme/J33Q/WzF7bBkVvhEWDlcBiUyZaim5CpFQwAAACceyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXRhZ3NlcnZpY2VzLmNvbTo0NDMiLCJmZWF0dXJlIjoiQ29udmVyc2lvbk1lYXN1cmVtZW50IiwiZXhwaXJ5IjoxNjQzMTU1MTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlLCJ1c2FnZSI6InN1YnNldCJ9"><link rel="preload" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/integrator_002.js" as="script"><link rel="preload" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/integrator.js" as="script"><link rel="preload" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/integrator_002.js" as="script"><link rel="preload" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/integrator.js" as="script"><link rel="preload" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/integrator_002.js" as="script"><link rel="preload" href="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/integrator.js" as="script"></head>

<body aria-hidden="false" topmargin="0" rightmargin="0" leftmargin="0" bottommargin="0">
<a name="top" id="top"></a>
  <table width="780" cellspacing="0" cellpadding="0" border="0" align="center">
    <tbody><tr height="20">
      <td>&nbsp;</td>
      <td width="100%">&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td valign="top" background="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/shad_left.gif">
      <img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/shad_top_left.gif" width="11" height="17" border="0"></td>
      <td width="100%" valign="top">
      <table width="100%" cellspacing="1" border="0" bgcolor="#000000">
        <tbody><tr>
          <td width="100%">
            <table width="100%" cellspacing="0" cellpadding="0" border="0">
              <tbody><tr>
                <td class="pathway" valign="center" align="left"><img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/arrow.png" hspace="5">
                <span class="breadcrumbs pathway">
<a href="http://microsin.net/programming/index.html" class="pathway">Программирование</a> <img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/arrow.png" alt=""> <a href="http://microsin.net/programming/pc/index.html" class="pathway">PC</a> <img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/arrow.png" alt=""> Потоки на C#. Часть 5: параллельное программирование</span>

                </td>
                <td class="pathway" valign="center" align="right">
                Tue, February 01 2022&nbsp;&nbsp;</td>
              </tr>
            </tbody></table>
          </td>
        </tr>
        <tr height="80">
          <td width="100%" bgcolor="#54647A" background="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/logo_bar_logo.jpg" align="left"></td>
        </tr>
        <tr>
          <td width="100%" bgcolor="#AFC6DB" background="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/but_bar_back.gif">

          		<div class="moduletable_topmenu">
					<table width="100%" cellspacing="1" cellpadding="0" border="0"><tbody><tr><td nowrap="nowrap"><span class="mainlevel">  | </span><a href="http://microsin.net/" class="mainlevel">Главная</a><span class="mainlevel">  | </span><a href="http://microsin.net/mycontacts.html" class="mainlevel">Контакты</a><span class="mainlevel">  | </span><a href="http://microsin.net/adminstuff/index.html" class="mainlevel">Администрирование</a><span class="mainlevel">  | </span><a href="http://microsin.net/programming/index.html" class="mainlevel" id="active_menu">Программирование</a><span class="mainlevel">  | </span><a href="http://microsin.net/Ssyilki/index.html" class="mainlevel">Ссылки</a><span class="mainlevel">  | </span></td></tr></tbody></table>		</div>
	

                    </td>
        </tr>
        <tr>
          <td width="100%" bgcolor="#FFFFFF">
          <table style="border-collapse: collapse" id="AutoNumber1" width="100%" cellspacing="0" cellpadding="4" border="0">
            <tbody><tr>
              <!-- LEFT Modules -->
              
                  <td width="150" valign="top" bgcolor="#F0F0F0">
                    <div class="modules" style="width:155px;">
                    		<div class="moduletable">
					<table border="0">
<tbody>
<tr>
<td><img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/UK-flag-ico.png" alt="UK-flag-ico.png" title="English site version" border="0" align="bottom"></td>
<td><a href="http://translate.google.ru/translate?hl=ru&amp;sl=ru&amp;tl=en&amp;u=http%3A%2F%2Fmicrosin.net%2F">English Version</a></td>
</tr>
<tr>
<td><img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/GERMAN-flag-ico.png" alt="GERMAN-flag-ico.png" title="Die deutsche Version der Webseite" border="0" align="bottom"></td>
<td><a href="http://translate.google.ru/translate?hl=ru&amp;sl=ru&amp;tl=de&amp;u=http%3A%2F%2Fmicrosin.net%2F">Die deutsche Version</a></td>
</tr>
</tbody>
</table>
<a href="http://microsin.net/xmap-1.html">Карта сайта</a>		</div>
			<div class="moduletable">
					<h3>Поделиться</h3>
					<!-- http://api.yandex.ru/share/ -->
 <div class="yashare-auto-init" data-yasharel10n="ru" data-yasharetype="none" data-yasharequickservices="vkontakte,facebook,twitter,moimir,lj,yaru,friendfeed"><span class="b-share"><a rel="nofollow" target="_blank" title="ВКонтакте" class="b-share__handle b-share__link b-share-btn__vkontakte" href="https://share.yandex.net/go.xml?service=vkontakte&amp;url=http%3A%2F%2Fmicrosin.net%2Fprogramming%2Fpc%2Fthreading-in-csharp-part-5-parallel-programming.html%23SpinLock_and_SpinWait&amp;title=%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205%3A%20%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%7C%20pc%20%7C%20programming" data-service="vkontakte"><span class="b-share-icon b-share-icon_vkontakte"></span></a><a rel="nofollow" target="_blank" title="Facebook" class="b-share__handle b-share__link b-share-btn__facebook" href="https://share.yandex.net/go.xml?service=facebook&amp;url=http%3A%2F%2Fmicrosin.net%2Fprogramming%2Fpc%2Fthreading-in-csharp-part-5-parallel-programming.html%23SpinLock_and_SpinWait&amp;title=%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205%3A%20%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%7C%20pc%20%7C%20programming" data-service="facebook"><span class="b-share-icon b-share-icon_facebook"></span></a><a rel="nofollow" target="_blank" title="Twitter" class="b-share__handle b-share__link b-share-btn__twitter" href="https://share.yandex.net/go.xml?service=twitter&amp;url=http%3A%2F%2Fmicrosin.net%2Fprogramming%2Fpc%2Fthreading-in-csharp-part-5-parallel-programming.html%23SpinLock_and_SpinWait&amp;title=%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205%3A%20%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%7C%20pc%20%7C%20programming" data-service="twitter"><span class="b-share-icon b-share-icon_twitter"></span></a><a rel="nofollow" target="_blank" title="Мой Мир" class="b-share__handle b-share__link b-share-btn__moimir" href="https://share.yandex.net/go.xml?service=moimir&amp;url=http%3A%2F%2Fmicrosin.net%2Fprogramming%2Fpc%2Fthreading-in-csharp-part-5-parallel-programming.html%23SpinLock_and_SpinWait&amp;title=%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205%3A%20%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%7C%20pc%20%7C%20programming" data-service="moimir"><span class="b-share-icon b-share-icon_moimir"></span></a><a rel="nofollow" target="_blank" title="LiveJournal" class="b-share__handle b-share__link b-share-btn__lj" href="https://share.yandex.net/go.xml?service=lj&amp;url=http%3A%2F%2Fmicrosin.net%2Fprogramming%2Fpc%2Fthreading-in-csharp-part-5-parallel-programming.html%23SpinLock_and_SpinWait&amp;title=%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205%3A%20%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%7C%20pc%20%7C%20programming" data-service="lj"><span class="b-share-icon b-share-icon_lj"></span></a></span></div>		</div>
			<div class="moduletable">
					

<form id="acesearchModule-10034" action="/component/option,com_acesearch/view,search/" method="post" name="acesearchModule" onsubmit="return acesearchsubmit();">
	<div class="search acesearch_bg_module">
		<input type="text" name="query" value="..." id="qr-10034" class="acesearch_input_module_modif" onblur="if(this.value=='') this.value='...';" onfocus="if(this.value=='...') this.value='';" style="margin-right:5px;" autocomplete="off"><a style="float:left;padding-left:5px;" href="http://microsin.net/component/option,com_acesearch/view,advancedsearch/" title="Расширенный поиск">Расширенный поиск</a><input type="hidden" name="lang" value="ru">	</div>
	
	<input type="hidden" name="option" value="com_acesearch">
	<input type="hidden" name="view" value="search">
	<input type="hidden" name="task" value="search">
</form>
<div class="acesearch_clear_mod_bottom"></div>		</div>
			<div class="moduletable">
					<h3>Нашли опечатку?</h3>
					Пожалуйста, сообщите об этом - просто выделите ошибочное слово или фразу и нажмите <b>Shift Enter</b>.		</div>
			<div class="moduletable">
					<!-- <a href="/images/stories/programming/AT90USB162fuses.JPG" target="_self"><img style="width: 120px; height: 128px; margin: 5px;" title="AT90USB162fuses.JPG" src="/images/stories/programming/AT90USB162fuses.JPG" alt="AT90USB162fuses.JPG" width="120" height="128" align="bottom" /></a> -->
<br>
<table>
   <tbody>
      <tr>
         <td><img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/ronkathehead-small.jpg"></td>
         <td><a href="https://vk.com/ronkathehead">Блог одного Сумасшествия</a></td>
      </tr>
   </tbody>
</table>		</div>
	
<br> <!-- ��� ��� ������� �� ���������� ������ -->
                    </div>
                  </td>
                                <td valign="top">
              <!-- Top Modules -->
                                          <div class="nopad"><table class="contentpaneopen">
<tbody><tr>
		<td class="contentheading" width="100%">
					Потоки на C#. Часть 5: параллельное программирование			</td>
				
				<td class="buttonheading" width="100%" align="right">
		<a href="http://microsin.net/programming/pc/threading-in-csharp-part-5-parallel-programming/Pechat.html" title="Печать" onclick="window.open(this.href,'win2','status=no,toolbar=no,scrollbars=yes,titlebar=no,menubar=no,resizable=yes,width=640,height=480,directories=no,location=no'); return false;" rel="nofollow"><img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/printButton.png" alt="Печать"></a>		</td>
		
					</tr>
</tbody></table>

<table class="contentpaneopen">
<tbody><tr>
	<td valign="top">
		<span class="small">
			Добавил(а) microsin		</span>
		&nbsp;&nbsp;
	</td>
</tr>



<tr>
<td valign="top">
<p>В этой части документации мы рассмотрим то новое в многопоточном API 
для использования с многоядерными процессорами, которое появилось в 
версии Framework 4.0:</p>
<p>• Parallel LINQ или PLINQ.<br>• Класс Parallel.<br>• Конструкции для параллельного выполнения задач (task parallelism).<br>• Коллекции одновременного выполнения (concurrent collections).<br>• SpinLock и SpinWait.</p>



<p>Это API также известно как PFX (Parallel Framework, аббревиатура ИМХО
 несколько ошибочная). Класс Parallel вместе с конструкциями 
параллелизма задач называется библиотекой параллельных задач, или TPL 
(Task Parallel Library).</p>
<p>Framework 4.0 также добавил несколько низкоуровневых конструкций для 
потоков, которые выполняют традиционные для многопоточности задачи. Мы 
их уже рассматривали ранее [5]:</p>
<p>• Конструкции сигнализации с малыми задержками (low-latency signaling
 constructs) SemaphoreSlim, ManualResetEventSlim, CountdownEvent и 
Barrier.<br>• Маркеры отмены (cancellation tokens) для кооперативной отмены действий (cooperative cancellation).<br>• Классы ленивой инициализации (lazy initialization classes).<br>• ThreadLocal&lt; T&gt;.</p>
<p>Для комфортного понимания перед дальнейшим чтением желательно 
ознакомиться с частями 1..4 документации [2, 3, 4, 5] - в частности для 
изучения блокировок (locking) и безопасности совместной работы потоков 
(thread safety).</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Все 
листинги кода секций параллельного программирования доступны как 
интерактивные примеры в LINQPad [6]. LINQPad это электронный блокнот, 
идеально подходящий для проверки блоков кода C# без необходимости 
создания окружающего класса, проекта или решения (имеется в виду среда 
Microsoft Visual Studio). Для получения доступа к примерам кликните на 
"Download More Samples" закладки " на закладке" в LINQPad, находящейся 
слева внизу, и выберите "C# 4.0 in a Nutshell: More Chapters".</span></p>
<p>[<strong>Почему PFX?</strong>]</p>
<p>В последнее время тактовые частоты CPU перестали расти, и 
производители переключились увеличение процессорных ядер. Это создало 
некоторую проблему для нас как для программистов, потому что стандартный
 однопоточный код не будет автоматически работать быстрее из-за 
увеличения числа ядер.</p>
<p>Задействование многих ядер проще реализовать в большинстве серверных 
приложений, где каждый поток независимо от других потоков работает над 
обработкой отдельного запроса пользователя, но сложнее то же самое 
сделать в приложении декстопа - потому что это обычно требует от 
нагруженного вычислениями кода реализации следующих функций:</p>
<p><strong>1</strong>. Разбиение всей вычислительной задачи на малые части.<br><strong>2</strong>. Запуск параллельной обработки этих частей с помощью многопоточности.<br><strong>3</strong>. Собрать все результаты работы вместе, когда они станут доступны.</p>
<p>Последнее нужно сделать таким образом, чтобы не повредить совместной 
работе потоков ни с точки зрения безопасности и устойчивости 
(thread-safe), ни с точки производительности. Хотя Вы можете сделать все
 это классическими конструкциями многопоточности, это будет грубым 
подходом - в частности на шагах разделения общей задачи на части и 
последующей сборки результатов работы потоков. Другая проблема в том, 
что обычная стратегия блокировки для безопасности потоков вызывает 
большую конкуренцию потоков, когда много потоков работают над одними и 
теми же данными сразу.</p>
<p>Библиотеки PFX разработаны специально для того, чтобы помочь программировать в этих сценариях.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Программирование
 с целью задействования нескольких ядер или нескольких процессоров 
называется параллельным программированием. Это подмножество более 
широкой концепции многопоточности.</span></p>
<p><strong>Концепции PFX</strong>. Существует 2 стратегии для разделения
 общей работы между потоками: параллелизм данных (data parallelism) и 
параллелизм задач (task parallelism).</p>
<p>Когда набор задач нужно выполнить на многих значениях данных, мы 
можем распараллелить всю задачу так, чтобы каждый поток выполнял 
(одинаковый) набор действий над подмножеством значений. Такой подход 
называется data parallelism, потому что мы распределяем обрабатываемые 
данные между потоками. В отличие от этого task parallelism подразумевает
 выполнение разными потоками разных задач; другими словами, каждый поток
 выполняет отличающий от других потоков алгоритм действий.</p>
<p>В общем случае data parallelism проще реализуется и лучше 
масштабируется для повышения количества ядер, потому что такой подход 
снижает или вовсе убирает работу потоков над общими данными (благодаря 
чему снижается конкуренция потоков и легче решать проблемы 
thread-safety). Также параллелизм данных усиливает тот факт, что чаще 
есть больше значений данных, чем каких-то дискретных задач, что 
увеличивает потенциал параллелизма.</p>
<p>Параллелизм данных также способствует структурированному 
параллелизму, что означает, что параллельные единицы общей работы 
запускаются и завершаются в одном и том же месте программы. В отличие от
 этого параллелизм задач имеет тенденцию быть не структурированным, это 
означает, что элементы параллельной работы могут начаться и завершиться в
 местах, рассеянных по программе. Структурированный параллелизм проще, 
меньше подвержен ошибкам, и позволяет Вам обрабатывать трудное задание 
разделения и координацию потоков (и даже финальное сопоставление 
результатов) из библиотек.</p>
<p><strong>Компоненты PFX</strong>. PFX представляет два слоя 
функциональности. Верхний слой состоит из двух видов data parallelism 
API: библиотека PLINQ и класс Parallel. Нижний слой содержит классы 
параллелизма задач, плюс набор дополнительных конструкций, чтобы помочь с
 параллельным программированием.</p>
<p><img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/CSharp-Threading-ParallelProgramming.png" alt="CSharp Threading ParallelProgramming"></p>
<p>PLINQ предоставляет самый богатый функционал: автоматизация всех 
шагов параллелизации, включая разделение работы на задачи, запуск 
выполнение этих задач в потоках и конечное сопоставление результатов в 
одну выходную последовательность. Она называется декларативной - потому 
что Вы просто декларируете, что хотите распараллелить свою работу (что 
структурируете как запрос LINQ), и позволяете платформе позаботиться о 
деталях реализации. В отличие от такого подхода другой вариант работы 
императивный, здесь Вам нужно специально написать код для разделения 
задачи на части и сопоставления результатов обработки. В случае 
использования класса Parallel Вы должны собрать результаты работы 
потоков самостоятельно; с конструкциями параллелизма задач Вы должны 
также самостоятельно разделить работу на части:</p>
<table cellspacing="1" cellpadding="3" border="0" bgcolor="#8cacbb">
<tbody>
<tr style="background-color: #dee7ec;">
<td><strong>Решение для организации<br>параллельности</strong></td>
<td><strong>Разделение общей<br>работы на части</strong></td>
<td><strong>Сведение результатов</strong></td>
</tr>
<tr style="background-color: #ffffff;">
<td>PLINQ</td>
<td>ДА</td>
<td>ДА</td>
</tr>
<tr style="background-color: #ffffff;">
<td>Класс Parallel</td>
<td>ДА</td>
<td>нет</td>
</tr>
<tr style="background-color: #ffffff;">
<td>Параллелизм задач PFX</td>
<td>нет</td>
<td>нет</td>
</tr>
</tbody>
</table>
<p>Коллекции конкуренции (concurrent collections) и примитивы циклов 
опроса (spinning primitives) помогут Вам реализовать на низком уровне 
действия по параллельному программированию Это важно, потому что PFX 
была спроектирована для работы только на сегодняшней аппаратуре, но 
также может потребоваться работать с будущими моделями процессоров, где 
есть намного больше ядер. Если Вы хотите переместить кучу напиленной 
древесины, имея 32 рабочих, то самая большая трудность при перемещении 
древесины состоит в том, чтобы эти рабочие не мешали друг другу. То же 
самое с делением алгоритма между 32 ядрами: обычные блокировки 
используются для защиты доступа к общим ресурсам, результирующая 
блокировка может означать, что только часть этих ядер когда-либо будут 
на самом деле работать одновременно. Коллекции конкуренции специально 
настроены для высоко конкурентного доступа, с фокусом на минимизации или
 устранения блокировок. PLINQ и класс Parallel сами по себе полагаются 
на коллекции конкуренции и примитивы циклов опроса для эффективного 
управления работой.</p>
<p></p><div class="spoiler" id="1_spoiler">
                        <input type="hidden" class="opened" value="0">
			<div class="sp-head folded" id="1-sp-head">
			<div class="sp-head-click" id="1-sp-head-click"><a href="javascript:void(0)">PFX и традиционная многопоточность</a></div></div>
			<div style="margin: 0px; position: static; overflow: hidden; height: 0px;"><div class="sp-body" id="1-sp-body" style="margin: -274px 0px 0px;"><p></p>
<p>Традиционная многопоточность это один из сценариев, когда 
многопоточность дает выигрыш даже на одноядерной машине, когда на самом 
деле нет настоящего параллелизма. Мы рассматривали все это ранее: задачи
 такого класса призваны сохранить отзывчивость интерфейса пользователя с
 одновременным выполнением других задач наподобие загрузки веб-страниц.</p>
<p>Некоторые конструкции, которые мы рассмотрим в секциях параллельного 
программирования, также иногда полезны и для традиционной 
многопоточности. В частности:</p>
<p>• PLINQ и класс Parallel полезны, когда Вы хотите выполнять операции 
параллельно и затем ждать их завершения (структурированный параллелизм).
 Это включает незначительно нагружающие CPU задачи, такие как вызов 
веб-службы.<br>• Конструкции параллелизма задач полезны, когда Вы хотите
 запустить некую операцию в потоке пула, и также для управления работой 
задачи через продолжения выполнения (continuations) и 
родительские/дочерние задачи.<br>• Коллекции конкурентного выполнения иногда применимы, когда Вы хотите организовать потокобезопасную очередь, стек или словарь.<br>• BlockingCollection предоставляет простой способ реализовать структуры генератор/потребитель данных (producer/consumer).</p>
<p></p></div></div>
			</div><p></p>
<p>Когда следует использовать PFX. Изначально PFX предназначен для 
параллельного программирования: задействование ядер многоядерных 
процессоров для ускорения работы кода с интенсивными вычислениями.</p>
<p>Сложность в применении многих ядер показывает закон Амдала, который 
устанавливает, что максимальное улучшение производительности 
ограничивается порцией кода, которая обязательно должна выполняться 
последовательно. Например, если две трети времени алгоритма можно 
распараллелить, Вы не сможете превысить определенный порог 
производительности, даже если будете иметь в наличии бесконечное 
количество ядер [7].</p>
<p>Таким образом сначала нужно оценить узкое место, ограничивающее 
производительность кода. Также стоит определиться, насколько нужны в 
коде конкретные интенсивные вычисления - часто алгоритмическая 
оптимизация дает самый большой выигрыш в производительности. Однако 
недостаток такого подхода в том, что некоторые техники оптимизации 
усложняют реализацию параллелизма кода.</p>
<p>Самый большой выигрыш дает правильная организация пожалуй самого 
сложного момента параллелизма - где общая работа может быть просто 
разделена на части, которые можно эффективно выполнить каким-то 
алгоритмом (структурированный параллелизм лучше всего подходит для таких
 проблем). Примерами могут служить задачи по обработке изображений, ray 
tracing, атаки по подбору в прикладной математике или криптографии. 
Другой пример проблемы параллельности - реализация оптимизированной 
версии алгоритма быстрой сортировки - достижение хорошего результата не 
тривиально, и может потребовать применения не структурированного 
параллелизма.</p>
<p><a name="PLINQ"></a>[<strong>PLINQ</strong>]</p>
<p>PLINQ автоматически распараллеливает локальные запросы (LINQ 
queries). Достоинство PLINQ в том, что её легко использовать - платформа
 берет на себя заботу разделения общей работы и конечного сведения 
вместе результатов.</p>
<p>Чтобы использовать PLINQ просто вызовите AsParallel() на входной 
последовательности, и затем продолжите запрос LINQ, как обычно. 
Следующий запрос вычисляет простые числа между 3 и 100000 - при полном 
использовании всех ядер целевой машины:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// Вычисление последовательности простых чисел с использованием элементарного</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// (не оптимизированного) алгоритма.</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">//</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// Примечание: все коды листинга в этой главе доступны в LINQPad как</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// интерактивные куски кода. Для активации этих примеров кликните</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// "Download More Samples" на закладке Samples утилиты LINQPad,</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// находящейся слева внизу, и выберите "C# 4.0 in a Nutshell: More Chapters".</span>
IEnumerable&lt; <span style="color: #b00040;">int</span>&gt; numbers = Enumerable.Range (<span style="color: #666666;">3</span>, <span style="color: #666666;">100000</span>-<span style="color: #666666;">3</span>);
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> parallelQuery = 
   <span style="color: #008000; font-weight: bold;">from</span> n <span style="color: #008000; font-weight: bold;">in</span> numbers.AsParallel()
   <span style="color: #008000; font-weight: bold;">where</span> Enumerable.Range (<span style="color: #666666;">2</span>, (<span style="color: #b00040;">int</span>) Math.Sqrt (n)).All (i =&gt; n % i &gt; <span style="color: #666666;">0</span>)
   <span style="color: #008000; font-weight: bold;">select</span> n;
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span>[] primes = parallelQuery.ToArray();
</pre>
</div>
<p>AsParallel это метод расширения в System.Linq.ParallelEnumerable. Он 
оборачивает ввод в последовательность на базе ParallelQuery&lt; 
TSource&gt;, который запускает операторы запроса LINQ, которые Вы 
впоследствии вызываете, чтобы связать с альтернативным набором методов 
расширения, определенных в ParallelEnumerable. Это дает параллельные 
реализации каждого из стандартных операторов запроса. В сущности это 
работает по принципу разделения входной последовательности на куски, 
выполняемые в разных потоках, которые соединяются вместе обратно в одну 
выходную потребляемую последовательность.</p>
<p>На картинке ниже показан прицип распараллеливания выражения:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #ba2121;">"abcdef"</span>.AsParallel().Select(c =&gt; <span style="color: #b00040;">char</span>.ToUpper(c)).ToArray()
</pre>
</div>
<p><img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/CSharp-Threading-PLINQExecution.png" alt="CSharp Threading PLINQExecution"></p>
<p>Вызов AsSequential() разворачивает последовательность ParallelQuery 
так, чтобы последующие операторы запроса связали связались со 
стандартными операторами запроса и выполнились последовательно. Это 
нужно перед вызовом методов, которые имеют побочные эффекты или не 
безопасны в условиях многопоточности.</p>
<p>Для операторов запроса, которые принимают две входные 
последовательности (Join, GroupJoin, Concat, Union, Intersect, Except и 
Zip), Вы должны применить AsParallel() к обоим входным 
последовательностям (иначе будет выброшено исключение). Однако Вам не 
нужно продолжать применять AsParallel к запросу во время его выполнения,
 потому что операторы запроса PLINQ выводят другую последовательность 
ParallelQuery. Фактически повторный вызов AsParallel будет не 
эффективным, потому что вызовет слияние и повторное разделение запроса:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">mySequence.AsParallel()          <span style="color: #408080; font-style: italic;">// Оборачивает последовательность в ParallelQuery&lt; int&gt;</span>
          .Where (n =&gt; n &gt; <span style="color: #666666;">100</span>)  <span style="color: #408080; font-style: italic;">// Выводит другой ParallelQuery&lt; int&gt;</span>
          .AsParallel()          <span style="color: #408080; font-style: italic;">// Не требуется, и не эффективно!</span>
          .Select (n =&gt; n * n)
</pre>
</div>
<p>Не все операторы запроса можно эффективно распараллелить. Для тех, 
которые распараллелить нельзя, PLINQ вместо этого реализует 
последовательный оператор. PLINQ может также работать последовательно, 
если подозревает, что издержки параллелизации на самом деле замедлят 
определенный запрос.</p>
<p>PLINQ подходит только для локальных коллекций: он не работает с LINQ к
 SQL или Entity Framework, потому что в этих случаях LINQ транслируется в
 SQL, который затем выполняется на сервере баз данных. Однако Вы можете 
использовать PLINQ для выполнения дополнительных локальных запросов на 
результатах, полученных из запросов к базе данных.</p>
<p style="padding-left: 30px;"><span style="color: #800000;">Если запрос
 PLINQ выбрасывает исключение, то оно перебрасывается как 
AggregateException, у которого свойство InnerExceptions содержит 
реальное исключение (или исключения). Подробнее см. "Работа с 
AggregateException".</span></p>
<p></p><div class="spoiler" id="2_spoiler">
                        <input type="hidden" class="opened" value="0">
			<div class="sp-head folded" id="2-sp-head">
			<div class="sp-head-click" id="2-sp-head-click"><a href="javascript:void(0)">Почему AsParallel не используется по умолчанию?</a></div></div>
			<div style="margin: 0px; position: static; overflow: hidden; height: 0px;"><div class="sp-body" id="2-sp-body" style="margin: -309px 0px 0px;"><p></p>
<p>Так как AsParallel прозрачно распараллеливает запросы LINQ, возникает
 вопрос: почему Microsoft не делает по умолчанию простую параллелизацию 
стандартных операторов запроса, т. е. не применяет PLINQ по умолчанию?</p>
<p>Тут несколько причин. Во-первых, для того, чтобы применение PLINQ 
было полезным, должно присутствовать разумное количество интенсивной 
вычислительной работы, чтобы передать её на обработку рабочим потокам. 
Большинство запросов LINQ к объектам выполняются очень быстро, и к ним 
не только не нужно применять параллелизм, но это также будет вовлекать 
дополнительные ненужные вычислительные расходы на разделение задачи, 
сбор результатов вместе, координацию работы потоков, в результате все 
только замедлится.</p>
<p>Кроме того:</p>
<p>• Выход запроса PLINQ query (по умолчанию) может отличаться от запроса LINQ в контексте упорядочивания элементов.<br>• PLINQ оборачивает исключения в AggregateException (чтобы обработать ситуации выбрасывания множества исключений).<br>• PLINQ будет давать ненадежные результаты, если запросы вовлекают себя не безопасные для выполнения в потоках методы.</p>
<p>И наконец, PLINQ предлагает довольно много вариантов настройки. 
Обременение стандартных запросов LINQ к Objects API такими нюансами 
дополнительно отвлекало бы от выполнения общей задачи.</p>
<p></p></div></div>
			</div><p></p>
<p><strong>Баллистика параллельного выполнения</strong>. Как и обычные 
запросы LINQ, запросы PLINQ вычисляются "ленивым" способом. Это 
означает, что выполнение срабатывает только когда Вы начинаете 
потреблять результаты запроса - обычно в цикле foreach (хотя это может 
быть сделано и через оператор преобразования, такой как ToArray, или 
оператор, который возвращает один элемент или значение).</p>
<p>Однако по мере потребления результатов выполнение осуществляется 
несколько иначе по сравнению с обычными последовательными запросами. 
Последовательный запрос выполняется полностью потребителем в стиле 
"выталкивания" (pull): каждый элемент из входной последовательности 
выбирается точно тогда, когда этого требует потребитель. Параллельный 
запрос обычно использует независимые потоки для выборки элементов из 
входной последовательности немного перед тем, как это понадобилось 
потребителю (нечто похожее на телевизионный суфлер для дикторов или 
антишоковый буфер данных в CD-плеерах). Затем он обрабатывает элементы в
 параллельном запросе через цепочку запроса, сохраняя результаты в 
маленьком буфере, откуда они могут быть взяты по запросу потребителя. 
Если потребитель приостановил потребление данных или сразу прекратил их 
обработку, то процессор запроса также ставит на паузу или останавливает 
работу, чтобы зря не расходовать время CPU или память.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Вы можете 
подстроить буферизацию PLINQ вызовом WithMergeOptions после AsParallel. 
Значение по умолчанию AutoBuffered обычно дает самые лучшие результаты. 
NotBuffered запрещает буферизацию, что полезно, если Вы хотите увидеть 
результаты настолько быстро, насколько это возможно; FullyBuffered 
полностью кэширует весь набор результата перед тем, как он будет 
доступен потребителю (операторы OrderBy и Reverse в сущности работают по
 такому методу, как как и операторы элемента, агрегации и 
преобразования).</span></p>
<p>PLINQ и порядок следования. Побочный эффект от параллелизации 
операторов запроса состоит в том, что когда результаты соединяются 
вместе, то не обязательно они будут в том же порядке, в каком были на 
входе, что показано в предыдущей диаграмме. Другими словами, больше не 
соблюдается нормальное сохранение порядка следования данных запросов 
LINQ.</p>
<p>Если Вам необходимо сохранить порядок следования, то это можно 
принудительно активировать вызовом AsOrdered() после AsParallel():</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">myCollection.AsParallel().AsOrdered()...
</pre>
</div>
<p>Вызов AsOrdered ухудшает производительность с большим количеством 
элементов, потому что PLINQ должна отслеживать оригинальную позицию 
каждого элемента.</p>
<p>Вы можете отменить в запросе действие AsOrdered позже вызовом 
AsUnordered: это вводит "точку случайной перетасовки" что позволяет 
запросу с этого момента выполняться более эффективно. Если Вам нужно 
сохранить входную последовательность только для двух первых операторов 
запроса, то сделайте так:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">inputSequence.AsParallel().AsOrdered()
   .QueryOperator1()
   .QueryOperator2()
   .AsUnordered()       <span style="color: #408080; font-style: italic;">// С этого места очередность данных не соблюдается.</span>
   .QueryOperator3()
   ...
</pre>
</div>
<p>Поведение AsOrdered не активировано по умолчанию, потому что для 
большинства запросов оригинальный порядок входных данных не имеет 
значения. Другими словами, если бы AsOrdered действовало по умолчанию, 
то Вы применяли бы AsUnordered для большинства своих параллельных 
запросов для получения самой лучшей производительности (иначе зачем нам 
параллелизм), что было бы обременительно.</p>
<p><strong>Ограничения PLINQ</strong>. Есть несколько практических 
ограничений на то, что PLINQ мог бы распараллелить. Эти ограничения 
могут впоследствии быть устранены последующими сервис-паками и более 
новыми версиями Framework.</p>
<p>Следующие операторы запроса не поддаются параллелизации, если их 
исходные элементы не находятся в своей исходной позиции индексации:</p>
<p>• Take, TakeWhile, Skip и SkipWhile.</p>
<p>• Индексированные версии Select, SelectMany и ElementAt.</p>
<p>Большинство операторов запроса меняют позицию индексации элементов 
(включая те, которые удаляют элементы, такие как Where). Это означает, 
что если Вы хотите использовать такие предшествующие операторы, то они 
должны быть перед запросом.</p>
<p>Следующие операторы запроса могут быть распараллелены, но используют 
затратную стратегию разделения, которая иногда может работать медленнее,
 чем последовательная обработка:</p>
<p>• Join, GroupBy, GroupJoin, Distinct, Union, Intersect и Except.</p>
<p>Отобранные перегрузки оператора Aggregate в своих стандартных 
инкарнациях не параллелизуются - PLINQ для них предоставляет специальные
 перегрузки.</p>
<p>Все другие операторы параллелизуются, хотя их использование не дает 
гарантии, что Ваш запрос будет распараллелен. PLINQ может запустить Ваш 
запрос последовательно, если заподозрит, что дополнительные затраты на 
параллелизацию дадут эффект замедления определенного запроса. Вы можете 
отменить такое поведение и принудительно заставить применять 
параллельную обработку путем вызова следующего оператора после 
AsParallel():</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">.WithExecutionMode (ParallelExecutionMode.ForceParallelism)
</pre>
</div>
<p></p><div class="spoiler" id="3_spoiler">
                        <input type="hidden" class="opened" value="0">
			<div class="sp-head folded" id="3-sp-head">
			<div class="sp-head-click" id="3-sp-head-click"><a href="javascript:void(0)">Пример: параллельная проверка орфографии</a></div></div>
			<div style="margin: 0px; position: static; overflow: hidden; height: 0px;"><div class="sp-body" id="3-sp-body" style="margin: -1205px 0px 0px;"><p></p>
<p>Предположим, что нам нужно написать спеллчекер, который быстро 
обрабатывает большие документы, напрягая все доступные ядра. Путем 
формулирования нашего алгоритма в виде запроса LINQ мы могли бы очень 
просто распараллелить его.</p>
<p>Первый шаг состоит в загрузке словаря английских слов в HashSet для эффективного обращения к нему:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">if</span> (!File.Exists (<span style="color: #ba2121;">"WordLookup.txt"</span>))   <span style="color: #408080; font-style: italic;">// Тут содержится около 150000 слов</span>
   <span style="color: #008000; font-weight: bold;">new</span> <span style="color: #0000ff;">WebClient</span>().DownloadFile (
      <span style="color: #ba2121;">"http://www.albahari.com/ispell/allwords.txt"</span>, <span style="color: #ba2121;">"WordLookup.txt"</span>);
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> wordLookup = <span style="color: #008000; font-weight: bold;">new</span> HashSet&lt; <span style="color: #b00040;">string</span>&gt; (
   File.ReadAllLines (<span style="color: #ba2121;">"WordLookup.txt"</span>),
   StringComparer.InvariantCultureIgnoreCase);
</pre>
</div>
<p>ОК, теперь создадим из нашей словарной таблицы тестовый "документ", 
представляющий массив из миллиона случайных слов. После сборки этого 
массива введем в него несколько орфографических ошибок:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> random = <span style="color: #008000; font-weight: bold;">new</span> Random();</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">string</span>[] wordList = wordLookup.ToArray();
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">string</span>[] wordsToTest = Enumerable.Range (<span style="color: #666666;">0</span>, <span style="color: #666666;">1000000</span>)
   .Select (i =&gt; wordList [random.Next (<span style="color: #666666;">0</span>, wordList.Length)])
   .ToArray();
 
wordsToTest [<span style="color: #666666;">12345</span>] = <span style="color: #ba2121;">"woozsh"</span>;  <span style="color: #408080; font-style: italic;">// Это введет пару ошибок</span>
wordsToTest [<span style="color: #666666;">23456</span>] = <span style="color: #ba2121;">"wubsie"</span>;  <span style="color: #408080; font-style: italic;">// орфографии.</span>
</pre>
</div>
<p>Теперь мы можем выполнить нашу параллельную проверку орфографии путем
 тестирования wordsToTest на соответствие словарю wordLookup. PLINQ 
делает это очень просто:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> query = wordsToTest
   .AsParallel()
   .Select  ((word, index) =&gt; <span style="color: #008000; font-weight: bold;">new</span> IndexedWord { Word=word, Index=index })
   .Where   (iword =&gt; !wordLookup.Contains (iword.Word))
   .OrderBy (iword =&gt; iword.Index);
 
query.Dump();        <span style="color: #408080; font-style: italic;">// Отображение результата в LINQPad</span>
</pre>
</div>
<p>Вот результат, который покажет LINQPad:</p>
<table cellspacing="1" cellpadding="3" border="0" bgcolor="#8cacbb">
<tbody>
<tr style="background-color: #dee7ec;">
<td colspan="2"><b>OrderedParallelQuery&lt; IndexedWord&gt; (2 элемента)</b></td>
</tr>
<tr style="background-color: #ffffff;">
<td><em><strong>Слово</strong></em></td>
<td><em><strong>Индекс</strong></em></td>
</tr>
<tr style="background-color: #ffffff;">
<td>woozsh</td>
<td>12345</td>
</tr>
<tr style="background-color: #ffffff;">
<td>wubsie</td>
<td>23456</td>
</tr>
</tbody>
</table>
<p>IndexedWord это пользовательская структура, которую мы определили следующим образом:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">struct</span> <span style="color: #0000ff; font-weight: bold;">IndexedWord</span> { <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #b00040;">string</span> Word; <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #b00040;">int</span> Index; }
</pre>
</div>
<p>Метод wordLookup.Contains в предикате дает запросу некую "суть" и делает его достойным параллелизации.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Мы могли бы
 немного упростить запрос с помощью анонимного типа вместо структуры 
IndexedWord. Однако это снизило бы производительность, потому что 
анонимные типы (которые являются классами, и поэтому ссылочными типами) 
привели бы к выделению памяти в куче и последующий за этим сбор мусора.</span></p>
<p style="padding-left: 30px;"><span style="color: #008080;">Разница в 
производительности между кэшем и стеком могла бы быть незначительной с 
последовательными запросами, но с параллельными запросами стековое 
выделение памяти может быть довольно выгоднее. Причина в том, что 
стековое выделение памяти очень хорошо параллелизуется (у каждого потока
 свой собственный стек), в то же время все потоки должны конкурировать 
друг с другом на куче, что управляется одним менеджером памяти и 
сборщиком мусора.</span></p>
<p>Использование ThreadLocal&lt; T&gt;. Давайте расширим наш пример 
параллелизацией создания самого массива тестовых слов. Структурируем его
 алгоритм в запрос LINQ, что должно быть просто. Вот так выглядит 
последовательная версия:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">string</span>[] wordsToTest = Enumerable.Range (<span style="color: #666666;">0</span>, <span style="color: #666666;">1000000</span>)
   .Select (i =&gt; wordList [random.Next (<span style="color: #666666;">0</span>, wordList.Length)])
   .ToArray();
</pre>
</div>
<p>К сожалению, вызов random.Next не потокобезопасен, так что не так 
просто вставить AsParallel() в этот запрос. Потенциальное решение 
проблемы - написать функцию, которая будет делать блокировку вокруг 
вызван random.Next; однако это снизило бы эффективность параллельности. 
Лучше всего использовать ThreadLocal&lt; Random&gt;, чтобы создать 
отдельный объект Random для каждого потока. Тогда мы сможем 
распараллелить запрос следующим образом:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> localRandom = <span style="color: #008000; font-weight: bold;">new</span> ThreadLocal&lt; Random&gt;
   ( () =&gt; <span style="color: #008000; font-weight: bold;">new</span> Random (Guid.NewGuid().GetHashCode()) );
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">string</span>[] wordsToTest = Enumerable.Range (<span style="color: #666666;">0</span>, <span style="color: #666666;">1000000</span>).AsParallel()
   .Select (i =&gt; wordList [localRandom.Value.Next (<span style="color: #666666;">0</span>, wordList.Length)])
   .ToArray();
</pre>
</div>
<p>Наша дополнительная функция нужна для инстанциации объекта Random. В 
неё мы передаем хеш-код Guid, чтобы гарантировать, что если два объекта 
Random будут созданы в короткий промежуток времени, то они приведут к 
различным последовательностям случайного числа.</p>
<p></p></div></div>
			</div><p></p>
<p></p><div class="spoiler" id="4_spoiler">
                        <input type="hidden" class="opened" value="0">
			<div class="sp-head folded" id="4-sp-head">
			<div class="sp-head-click" id="4-sp-head-click"><a href="javascript:void(0)">Когда следует использовать PLINQ?</a></div></div>
			<div style="margin: 0px; position: static; overflow: hidden; height: 0px;"><div class="sp-body" id="4-sp-body" style="margin: -261px 0px 0px;"><p></p>
<p>Заманчиво было бы перебрать Ваши готовые приложения в поиске запросов
 LINQ, и поэкспериментировать с ними на предмет параллелизации. Это 
обычно не будет продуктивным, потому что большинство проблем, для 
решение которых LINQ лучше всего подходит, выполняются очень быстро, и 
параллелизация не даст выгоды. Лучше всего найти те места, где 
интенсивные вычисления CPU составляют узкое место в программе, после 
чего задать себе вопрос: "можно ли как-то представить эти вычисления в 
виде запроса LINQ?" (добро пожаловать в побочные эффекты 
реструктуризации кода, когда LINQ обычно уменьшает код и делает его 
более читаемым).</p>
<p>PLINQ также хорошо подходит для случаев, когда есть сложности с 
ручным распараллеливанием вычислений. Это также подходит для 
структурированных блокирующихся задач, таких как вызов нескольких 
веб-сервисов сразу (см. "Вызов блокирующих и интенсивных по вводу/выводу
 функций").</p>
<p>PLINQ может быть плохим выбором для обработки изображений, потому что
 сборка вместе миллионов точек в выходную последовательность станет 
узким местом программы. Вместо этого лучше всего записывать точки прямо 
массив не обслуживаемого блока памяти, и использовать класс Parallel или
 параллелизм задач для управления многопоточностью (однако есть 
возможность победить конечный сбор результатов обработки использованием 
ForAll. Так делать стоит, если алгоритм обработки изображения 
естественно укладывается в LINQ).</p>
<p></p></div></div>
			</div><p></p>
<p><strong>Функциональная чистота</strong>. Поскольку PLINQ запускает 
Ваш запрос в параллельных потоках, Вы должны остерегаться выполнять не 
безопасные для потоков операции. В частности, запись в переменные даст 
побочные эффекты, и поэтому не будет потокобезопасной:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// Следующий запрос умножает каждый элемент на его позицию.</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// Если на входе Enumerable.Range(0,999), то это должно дать на выходе</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// квадраты чисел.</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span> i = <span style="color: #666666;">0</span>;</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> query = <span style="color: #008000; font-weight: bold;">from</span> n <span style="color: #008000; font-weight: bold;">in</span> Enumerable.Range(<span style="color: #666666;">0</span>,<span style="color: #666666;">999</span>).AsParallel() <span style="color: #008000; font-weight: bold;">select</span> n * i++;
</pre>
</div>
<p>Мы могли бы сделать инкремент i потокобезопасным путем ввода 
блокировок или использования класса Interlocked [5], но проблема все еще
 останется, поскольку i не обязательно будет соответствовать позиции 
входного элемента. И добавление AsOrdered в запрос не решило бы эту 
проблему, потому что AsOrdered гарантирует только то, что элементы 
появятся на выходе в том же порядке, в каком они обрабатывались бы 
последовательно - но это не даст их действительную последовательную 
обработку.</p>
<p>Вместо этого запрос нужно переписать с использованием индексированной версии Select:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> query = Enumerable.Range(<span style="color: #666666;">0</span>,<span style="color: #666666;">999</span>).AsParallel().Select ((n, i) =&gt; n * i);
</pre>
</div>
<p>Для лучшей производительности любые методы, вызываемые из операторов 
запроса, должны быть потокобезопасными, для чего они не должны 
записывать что-то в поля или свойства (должны быть без побочных 
эффектов, или функционально чистыми). Если потокобезопасность 
достигается блокировкой, то параллелизм запроса потенциально будет 
ограничен - на коэффициент, равный длительности блокировки, поделенной 
на общее время, потраченное в этой функции.</p>
<p>Вызов блокирующих и интенсивных по вводу/выводу функций. Иногда 
запрос выполняется долго не из-за загрузки CPU, а из-за ожидания 
чего-нибудь - такого как ожидание завершения загрузки веб-страницы или 
ответа аппаратуры. PLINQ может эффективно распараллелить такие запросы, 
если Вы дадите ему подсказку, вызвав WithDegreeOfParallelism после 
AsParallel. Например предположим, что мы хотим выполнить пинг шести 
web-сайтов одновременно. Вместо того, чтобы использовать неуклюжих 
асинхронных делегатов или вручную запускать 6 потоков, это можно 
эффективно выполнить запросом PLINQ:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">from</span> site <span style="color: #008000; font-weight: bold;">in</span> <span style="color: #008000; font-weight: bold;">new</span>[]
{
   <span style="color: #ba2121;">"www.albahari.com"</span>,
   <span style="color: #ba2121;">"www.linqpad.net"</span>,
   <span style="color: #ba2121;">"www.oreilly.com"</span>,
   <span style="color: #ba2121;">"www.takeonit.com"</span>,
   <span style="color: #ba2121;">"stackoverflow.com"</span>,
   <span style="color: #ba2121;">"www.rebeccarey.com"</span>  
}
.AsParallel().WithDegreeOfParallelism(<span style="color: #666666;">6</span>)
let p = <span style="color: #008000; font-weight: bold;">new</span> Ping().Send (site)</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">select</span> <span style="color: #008000; font-weight: bold;">new</span>
{
   site,
   Result = p.Status,
   Time = p.RoundtripTime
}
</pre>
</div>
<p>WithDegreeOfParallelism принуждает PLINQ запустить указанное 
количество потоков (в данном примере 6) одновременно. Это необходимо, 
когда вызываются такие блокирующие выполнение потока функции, как 
Ping.Send, потому что PLINQ иначе предполагает, что запрос интенсивно 
загружает CPU, и выделяет задачи соответствующим образом. Например, на 
двухядерной машине PLINQ может по умолчанию запустить одновременно 
только 2 задачи, что в данной ситуации очень нежелательно.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">PLINQ 
обычно обслуживает каждую задачу в потоке согласно выделению в пуле 
потоков. Вы можете ускорить начальный запуск потоков вызовом 
ThreadPool.SetMinThreads.</span></p>
<p>Для другого примера предположим, что мы пишем систему наблюдения, и 
хотим с повторами комбинировать изображения из 4 камер безопасности в 
одно общее изображение для отображения на мониторе наблюдения. 
Представим камеру следующим классом:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">class</span> <span style="color: #0000ff; font-weight: bold;">Camera</span>
{
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">readonly</span> <span style="color: #b00040;">int</span> CameraID;
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #0000ff;">Camera</span> (<span style="color: #b00040;">int</span> cameraID) { CameraID = cameraID; }
 
   <span style="color: #408080; font-style: italic;">// Получение изображения с камеры: вернет простую строку вместо картинки.</span>
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #b00040;">string</span> <span style="color: #0000ff;">GetNextFrame</span>()
   {
      Thread.Sleep (<span style="color: #666666;">123</span>);     <span style="color: #408080; font-style: italic;">// Симуляция времени получения снимка.</span>
      <span style="color: #008000; font-weight: bold;">return</span> <span style="color: #ba2121;">"Кадр из камеры "</span> + CameraID;
   }
}
</pre>
</div>
<p>Чтобы получить составную картинку, мы должны вызвать GetNextFrame на 
каждом объекте камеры. Если заранее знать, что эта операция привязана к 
интенсивному вводу/выводу, то можно ускорить в 4 раза скорость смены 
кадров на мониторе применением параллелизации - даже на одноядерной 
машине. PLINQ делает это возможным с минимальными усилиями:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Camera[] cameras = Enumerable.Range (<span style="color: #666666;">0</span>, <span style="color: #666666;">4</span>)   <span style="color: #408080; font-style: italic;">// Создание 4 объектов камер.</span>
   .Select (i =&gt; <span style="color: #008000; font-weight: bold;">new</span> Camera (i))
   .ToArray();
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">while</span> (<span style="color: #008000; font-weight: bold;">true</span>)
{
   <span style="color: #b00040;">string</span>[] data = cameras
      .AsParallel().AsOrdered().WithDegreeOfParallelism (<span style="color: #666666;">4</span>)
      .Select (c =&gt; c.GetNextFrame()).ToArray();
 
   Console.WriteLine (<span style="color: #b00040;">string</span>.Join (<span style="color: #ba2121;">", "</span>, data));   <span style="color: #408080; font-style: italic;">// Отображение данных...</span>
}
</pre>
</div>
<p>GetNextFrame является блокирующимся методом, поэтому мы используем 
WithDegreeOfParallelism, чтобы достичь нужной параллельности. В нашем 
примере блокировка происходит, когда мы вызываем Sleep; в реальной жизни
 блокировка будет происходить из-за получения изображения из камеры, 
потому что поток ввода/вывода данных с камеры требует просто ожидания 
данных и не вовлекает интенсивное использование CPU.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Вызов 
AsOrdered гарантирует, что картинки будут отображается в определенном 
порядке. Поскольку здесь только 4 элемента в последовательности, это 
даст незначительный эффект на снижение производительности.</span></p>
<p><strong>Изменение степени параллелизма</strong>. Вы можете только 
один раз вызвать WithDegreeOfParallelism в запросе PLINQ. Если нужно 
вызвать его снова, то следует принудительно слить данные запроса и 
заново его разделить повторным вызовом AsParallel() в запросе:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #ba2121;">"The Quick Brown Fox"</span>
   .AsParallel().WithDegreeOfParallelism (<span style="color: #666666;">2</span>)
   .Where (c =&gt; !<span style="color: #b00040;">char</span>.IsWhiteSpace (c))
   .AsParallel().WithDegreeOfParallelism (<span style="color: #666666;">3</span>)    <span style="color: #408080; font-style: italic;">// Принудительное слияние + разделение</span>
   .Select (c =&gt; <span style="color: #b00040;">char</span>.ToUpper (c))
</pre>
</div>
<p><strong>Отмена запроса</strong> (Cancellation). Отмена запроса PLINQ,
 когда Вы потребляете его результаты в цикле foreach, осуществляется 
просто: обычный break в цикле foreach завершит прокрутку цикла, и запрос
 будет автоматически отменен поскольку перечислитель был неявно 
уничтожен.</p>
<p>Для запроса, который завершается на оператор преобразования, элемента
 или агрегации, его можно отменить из другого потока через маркер отмены
 (cancellation token). Чтобы вставить маркер (token), вызовите 
WithCancellation после вызова AsParallel, передав в свойстве Token 
объект CancellationTokenSource. После этого другой объект может вызвать 
Cancel на источнике маркера, что выбросит исключение 
OperationCanceledException в потребителе запроса:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">IEnumerable&lt; <span style="color: #b00040;">int</span>&gt; million = Enumerable.Range (<span style="color: #666666;">3</span>, <span style="color: #666666;">1000000</span>);
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> cancelSource = <span style="color: #008000; font-weight: bold;">new</span> CancellationTokenSource(); <span style="color: #b00040;">var</span> primeNumberQuery = 
   <span style="color: #008000; font-weight: bold;">from</span> n <span style="color: #008000; font-weight: bold;">in</span> million.AsParallel().WithCancellation (cancelSource.Token)
   <span style="color: #008000; font-weight: bold;">where</span> Enumerable.Range (<span style="color: #666666;">2</span>, (<span style="color: #b00040;">int</span>) Math.Sqrt (n)).All (i =&gt; n % i &gt; <span style="color: #666666;">0</span>)
   <span style="color: #008000; font-weight: bold;">select</span> n;
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">new</span> <span style="color: #0000ff;">Thread</span> (() =&gt; {
                    Thread.Sleep (<span style="color: #666666;">100</span>);      <span style="color: #408080; font-style: italic;">// Отмена запроса через</span>
                    cancelSource.Cancel();   <span style="color: #408080; font-style: italic;">// 100 миллисекунд.</span>
                  }
           ).Start();</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">try</span>
{
   <span style="color: #408080; font-style: italic;">// Запуск запроса в работу:</span>
   <span style="color: #b00040;">int</span>[] primes = primeNumberQuery.ToArray();
   <span style="color: #408080; font-style: italic;">// Сюда мы никогда не попадем, потому что другой поток отменит работу этого кода.</span>
}</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">catch</span> (OperationCanceledException)
{
   Console.WriteLine (<span style="color: #ba2121;">"Запрос отменен"</span>);
}
</pre>
</div>
<p>PLINQ не делает вытесняющий обрыв работы потока, потому что это 
опасно (см. "Прекращение работы потока" [5]). Вместо этого при отмене 
происходит ожидание завершения обработки текущего элемента у каждого 
рабочего потока перед завершением запроса. Это означает, что любые 
внешние методы, которые вызывает запрос, отработают до своего 
завершения.</p>
<p></p><div class="spoiler" id="5_spoiler">
                        <input type="hidden" class="opened" value="0">
			<div class="sp-head folded" id="5-sp-head">
			<div class="sp-head-click" id="5-sp-head-click"><a href="javascript:void(0)">Оптимизация PLINQ</a></div></div>
			<div style="margin: 0px; position: static; overflow: hidden; height: 0px;"><div class="sp-body" id="5-sp-body" style="margin: -1886px 0px 0px;"><p></p>
<p><strong>Оптимизация по выходу</strong>. Одно из достоинств PLINQ - 
удобно соединяются результаты распараллеленной работы в одну выходную 
последовательность. Хотя иногда все, что требуется - запустить некую 
функцию по одному разу на каждый элемент:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">foreach</span> (<span style="color: #b00040;">int</span> n <span style="color: #008000; font-weight: bold;">in</span> parallelQuery)
   DoSomething (n);
</pre>
</div>
<p>Если имеет место этот случай, и не имеет значения, в каком порядке 
будут обработаны элементы, то можно улучшить эффективность PLINQ методом
 ForAll.</p>
<p>Метод ForAll запускает делегата на каждый выходной элемент 
ParallelQuery. Это происходит напрямую в PLINQ, пропуская шаги слияния и
 перечисления результатов. Простейший пример:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #ba2121;">"abcdef"</span>.AsParallel().Select (c =&gt; <span style="color: #b00040;">char</span>.ToUpper(c)).ForAll (Console.Write);
</pre>
</div>
<p><img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/CSharp-Threading-ForAll.png" alt="CSharp Threading ForAll"></p>
<p style="padding-left: 30px;"><span style="color: #008080;">Сбор вместе
 и перечисление результатов не массивно дорогая операция, так что 
оптимизация ForAll уступает большим выгодам, когда большое количество 
быстро обрабатываемых входных элементов.</span></p>
<p><strong>Оптимизация по входу</strong>. У PLINQ есть 3 стратегии разделения задачи для передачи входных элементов потокам:</p>
<table cellspacing="1" cellpadding="3" border="0" bgcolor="#8cacbb">
<tbody>
<tr style="background-color: #dee7ec;">
<td><b>Стратегия</b></td>
<td><b>Выделение элемента</b></td>
<td><strong>Относительное быстродействие</strong></td>
</tr>
<tr style="background-color: #ffffff;">
<td>Chunk partitioning</td>
<td>Динамическое</td>
<td>Среднее</td>
</tr>
<tr style="background-color: #ffffff;">
<td>Range partitioning</td>
<td>Статическое</td>
<td>Плохое или отличное</td>
</tr>
<tr style="background-color: #ffffff;">
<td>Hash partitioning</td>
<td>Статическое</td>
<td>Плохое</td>
</tr>
</tbody>
</table>
<p>Для операторов запроса, которые требуют сравнения элементов (GroupBy,
 Join, GroupJoin, Intersect, Except, Union и Distinct), у Вас нет 
выбора: PLINQ всегда использует hash-разделение. Hash-разделение 
относительно не эффективное, потому что должно предварительно рассчитать
 хеш-код для каждого элемента (так что элементы с одинаковыми хеш-кодами
 можно было обработать в одном потоке). Если Вы решили, что это слишком 
медленно, то можете только вызвать AsSequential для запрета 
параллелизма.</p>
<p>Для всех других операторов запроса у Вас есть выбор - использовать 
разделение по диапазону (range) или по куску (chunk). По умолчанию:</p>
<p>• Если входная последовательность может быть проиндексирована (если 
это массив, или реализуется IList&lt; T&gt;), то PLINQ использует 
range-разделение.<br>• Иначе PLINQ выберет chunk-разделение.</p>
<p>В сущности range-разделение быстрее на длинных последовательностях, 
где обработка каждого элемента занимает примерно одинаковое время CPU. 
Иначе chunk-разделение обычно работает быстрее.</p>
<p>Чтобы принудительно включить range-разделение:</p>
<p>• Если запрос начинается на Enumerable.Range, замените его на ParallelEnumerable.Range.<br>•
 Иначе просто вызовите ToList или ToArray на входной последовательности 
(очевидно это снизит общую производительность, что следует учитывать).</p>
<p style="padding-left: 30px;"><span style="color: #800000;">ParallelEnumerable.Range
 это не просто ярлычок для вызова Enumerable.Range(...).AsParallel(). 
Это меняет производительность запроса путем активации range-разделения.</span></p>
<p>Чтобы принудительно включить chunk-разделение, оберните входную 
последовательность в вызов Partitioner.Create (находится в 
System.Collection.Concurrent) следующим образом:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span>[] numbers = { <span style="color: #666666;">3</span>, <span style="color: #666666;">4</span>, <span style="color: #666666;">5</span>, <span style="color: #666666;">6</span>, <span style="color: #666666;">7</span>, <span style="color: #666666;">8</span>, <span style="color: #666666;">9</span> };<br><span style="color: #b00040;">var</span> parallelQuery =
   Partitioner.Create (numbers, <span style="color: #008000; font-weight: bold;">true</span>).AsParallel()
   .Where (...)
</pre>
</div>
<p>Второй аргумент Partitioner.Create показывает, что Вы хотите 
сбалансировать запрос по нагрузке, что является другим способом указать,
 что нужно применить chunk-разделение.</p>
<p>Chunk-разделение работает таким образом, что каждый рабочий поток для
 обработки периодически берет малые порции элементов (chunks) из входной
 последовательности. PLINQ начинает с выделения очень маленьких кусков 
(из одного или двух элементов за один раз), затем увеличивает размер 
куска по мере выполнения запроса: это гарантирует, что малые 
последовательности будут эффективно распараллелены, и большие 
последовательности не приведут к чрезмерным расщеплениям входных данных.
 Если произойдет так, что рабочий поток получает "простые" элементы 
(которые обработаются быстро), то это закончится тем, что он получит 
больше кусков. Такая система удерживает каждый поток одинаково 
нагруженным (ядра получаются "сбалансированными" по нагрузке); 
недостаток в том, что выборка элементов из общей входной 
последовательности требует синхронизации (обычно исключительной 
блокировки), что может привести к некоторым дополнительным тратам по 
вычислениям и конкуренции потоков.</p>
<p><img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/CSharp-Threading-Partitioning.png" alt="CSharp Threading Partitioning"></p>
<p>Range-разделение пропускает обычное перечисление по входу, и 
предварительно выделяет одинаковое количество элементов для каждого 
потока, избегая состязания на входной последовательности. Но если 
произойдет так, что некоторые потоки получат простые элементы, и 
выполнят свою обработку быстрее, то они останутся в ожидании завершения 
обработки в остальных потоках. Наш предыдущий пример с числовыми 
вычислениями может показать плохую эффективность при range-разделении. 
Примером, когда range-разделение работает хорошо, будет вычисление суммы
 квадратных корней первых 10 миллионов целых чисел:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">ParallelEnumerable.Range (<span style="color: #666666;">1</span>, <span style="color: #666666;">10000000</span>).Sum (i =&gt; Math.Sqrt (i))
</pre>
</div>
<p>ParallelEnumerable.Range вернет ParallelQuery&lt; T&gt;, так что Вам не нужно впоследствии вызывать AsParallel.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Range-разделение
 не обязательно будет выделять диапазоны элементов в непрерывных блоках -
 вместо этого может быть выбрана стратегия чередования (striping). 
Например, если есть два рабочих потока, то один может обрабатывать 
элементы с четными номерами, в то время как другой процесс с нечетными. 
Оператор TakeWhile почти наверняка инициирует striping-стратегию, чтобы 
избежать нежелательной обработки элементов в последовательности.</span></p>
<p></p></div></div>
			</div><p></p>
<p><strong>Параллелизация пользовательских агрегаций</strong>. PLINQ 
эффективно распараллеливает операторы Sum, Average, Min и Max без 
дополнительного вмешательства. Однако оператор Aggregate представляет 
для PLINQ дополнительные сложности.</p>
<p>Если Вы не знакомы с этим оператором, то можете думать об Aggregate 
как про обобщенную версию Sum, Average, Min и Max - другими словами, это
 оператор, который позволят Вам подключить пользовательский алгоритм 
накопления для реализации необычных агрегаций. Следующий код 
демонстрирует, как Aggregate может выполнить работу Sum:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span>[] numbers = { <span style="color: #666666;">2</span>, <span style="color: #666666;">3</span>, <span style="color: #666666;">4</span> };</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span> sum = numbers.Aggregate (<span style="color: #666666;">0</span>, (total, n) =&gt; total + n);      <span style="color: #408080; font-style: italic;">// 9</span>
</pre>
</div>
<p>Первый аргумент для Aggregate это начальное значение (seed), с 
которого начинается накопление. Второй аргумент это выражение для 
обновления накапливаемого значения с учетом нового элемента. Опционально
 Вы можете предоставить третий аргумент для проектирования конечного 
результата из накопленного значения.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Большинство
 проблем, для которых был разработан Aggregate, можно решить проще с 
циклом foreach, с более знакомым синтаксисом. Достоинство Aggregate в 
том, что большие и сложные агрегации можно декларативно распараллелить с
 помощью PLINQ.</span></p>
<p><strong>Агрегации без начальной точки отсчета</strong> (unseeded). Вы
 может опустить значение seed при вызове Aggregate, в этом случае первый
 элемент станет неявным seed, и агрегация начнется со второго элемента. 
Вот предыдущий пример, переделанный на unseeded:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span>[] numbers = { <span style="color: #666666;">1</span>, <span style="color: #666666;">2</span>, <span style="color: #666666;">3</span> };</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span> sum = numbers.Aggregate ((total, n) =&gt; total + n);         <span style="color: #408080; font-style: italic;">// 6</span>
</pre>
</div>
<p>Это даст тот же результат, что и ранее, но реально мы делаем другое 
вычисление. Раньше мы выполнили вычисление 0+1+2+3; теперь же 1+2+3. Мы 
можем лучше проиллюстрировать разницу применением умножения вместо 
сложения:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span>[] numbers = { <span style="color: #666666;">1</span>, <span style="color: #666666;">2</span>, <span style="color: #666666;">3</span> };</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span> x = numbers.Aggregate (<span style="color: #666666;">0</span>, (prod, n) =&gt; prod * n);    <span style="color: #408080; font-style: italic;">// 0*1*2*3 = 0</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span> y = numbers.Aggregate (   (prod, n) =&gt; prod * n);    <span style="color: #408080; font-style: italic;">//   1*2*3 = 6</span>
</pre>
</div>
<p>Как мы скоро увидим, unseeded-агрегации имеют преимущество для 
параллелизации, так как не требуют использования специальных перегрузок.
 Но с unseeded-агрегациями можно попасть в ловушку: их методы 
предназначены для использования с делегатами, которые являются 
коммутативными и ассоциативными. При другом использовании любой 
результат будет не интуитивным (с обычными запросами) или не 
детерминированным (в случае, когда Вы распараллелили запрос с помощью 
PLINQ). Для примера рассмотрим следующую функцию:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">(total, n) =&gt; total + n * n
</pre>
</div>
<p>Она ни коммутативна, ни ассоциативна (т. е. 1+2*2 != 2+1*1). 
Посмотрим, что получится, когда мы используем её для сложения квадратов 
чисел 2, 3 и 4:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span>[] numbers = { <span style="color: #666666;">2</span>, <span style="color: #666666;">3</span>, <span style="color: #666666;">4</span> };</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span> sum = numbers.Aggregate ((total, n) =&gt; total + n * n);    <span style="color: #408080; font-style: italic;">// 27</span>
</pre>
</div>
<p>Вместо того, чтобы получить 29 как результат 2*2 + 3*3 + 4*4, 
получится 27 в результате вычисления 2 + 3*3 + 4*4. Мы можем исправить 
это несколькими способами. Первый способ - добавить 0 в качестве первого
 элемента:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span>[] numbers = { <span style="color: #666666;">0</span>, <span style="color: #666666;">2</span>, <span style="color: #666666;">3</span>, <span style="color: #666666;">4</span> };
</pre>
</div>
<p>Однако это не только не элегантно, но все еще даст некорректные 
результаты при параллелизации, потому что PLINQ усиливает 
подразумеваемую ассоциативность функции, выбирая несколько элементов как
 seed-значения. Для иллюстрации мы обозначим нашу функцию агрегации 
следующим образом:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">f(total, n) =&gt; total + n * n
</pre>
</div>
<p>тогда запрос LINQ к объектам вычислил бы f(f(f(0, 2),3),4), в то 
время как PLINQ мог бы сделать f(f(0,2),f(3,4)) со следующим 
результатом:</p>
<p>Первая часть распараллеливания: &nbsp;a = 0 + 2*2 &nbsp;(= 4)<br>Вторая часть распараллеливания: &nbsp;b = 3 + 4*4 &nbsp;(= 19)<br>Конечный результат: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a + b*b &nbsp;(= 365)<br>ИЛИ ДАЖЕ: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b + a*a &nbsp;(= 35)&nbsp;</p>
<p>Есть 2 хороших решения. Первое - превратить это в seeded-агрегацию с 
нулем для seed. Единственная сложность в том, что с PLINQ нам нужно 
использовать специальную перегрузку, чтобы запрос не выполнятся 
последовательно (скоро мы это увидим).</p>
<p>Второе решение реструктурировать запрос так, чтобы функция агрегации стала коммутативной и ассоциативной:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span> sum = numbers.Select (n =&gt; n * n).Aggregate ((total, n) =&gt; total + n);
</pre>
</div>
<p>Конечно, в таком простом сценарии Вы можете (и должны) использовать оператор Sum вместо Aggregate:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span> sum = numbers.Sum (n =&gt; n * n);
</pre>
</div>
<p>Вы можете на самом деле пойти довольно далеко просто с Sum и Average.
 Например, можно использовать Average для вычисления среднего 
квадратического значения (root-mean-square, RMS):</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Math.Sqrt (numbers.Average (n =&gt; n * n))
</pre>
</div>
<p>и даже стандартную девиацию:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">double</span> mean = numbers.Average();</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">double</span> sdev = Math.Sqrt (numbers.Average (n =&gt;
              {
                <span style="color: #b00040;">double</span> dif = n - mean;
                <span style="color: #008000; font-weight: bold;">return</span> dif * dif;
              }));
</pre>
</div>
<p>Оба варианта безопасны, эффективным и полностью параллелизуются.</p>
<p><strong>Параллелизация Aggregate</strong>. Мы только что говорили, 
что для unseeded-агрегаций предоставленный делегат должен быть 
ассоциативным и коммутативным. PLINQ даст некорректные результаты, если 
это правило нарушается, потому что это вовлечет несколько seed-значений 
из входной последовательности, чтобы одновременно агрегировать несколько
 частей последовательности.</p>
<p>Явные seed-агрегации могли бы выглядеть как безопасная опция с PLINQ,
 но к сожалению обычно они выполняются последовательно, потому что 
полагаются на одно значение seed. Чтобы смягчить это, PLINQ 
предоставляет другую перегрузку Aggregate, которая позволяет указать 
несколько значений seed - или скорее разработанную функцию для seed. Для
 каждого потока эта функция выполнится, чтобы генерировать отдельное 
значение seed, которое становится локальным аккумулятором для потока, в 
который будет выполняться агрегация элементов.</p>
<p>Мы также должны предоставить функцию для индикации, как комбинировать
 локальный и главный аккумуляторы. И наконец, эта перегрузка Aggregate 
(немного необоснованно) ожидает делегата для выполнения любого конечного
 преобразования для результата (того же самого результата Вы можете 
достичь, самостоятельно вызвав какую-нибудь функцию преобразования 
позже). Итак, имеется 4 делегата, передаваемых в таком порядке:</p>
<p>seedFactory. Вернет новый локальный аккумулятор.<br>updateAccumulatorFunc. Агрегирует элемент в локальный аккумулятор.<br>combineAccumulatorFunc. Комбинирует локальный аккумулятор с главным аккумулятором.<br>resultSelector. Применяет любое последнее преобразования к конечному результату.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">В простых 
сценариях Вы можете указать значение seed вместо функции seed (вместо 
seedFactory). Эта тактика не сработает, когда seed является ссылочным 
типом, который Вы хотите мутировать, потому что один и тот же экземпляр 
тогда будет использоваться каждым потоком.</span></p>
<p>В качестве очень простого примера рассмотрим следующие суммы значений в массиве чисел:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">numbers.AsParallel().Aggregate (
   () =&gt; <span style="color: #666666;">0</span>,                                     <span style="color: #408080; font-style: italic;">// seedFactory</span>
   (localTotal, n) =&gt; localTotal + n,           <span style="color: #408080; font-style: italic;">// updateAccumulatorFunc</span>
   (mainTot, localTot) =&gt; mainTot + localTot,   <span style="color: #408080; font-style: italic;">// combineAccumulatorFunc</span>
   finalResult =&gt; finalResult)                  <span style="color: #408080; font-style: italic;">// resultSelector</span>
</pre>
</div>
<p>В этом примере мы могли бы получить тот же ответ, используя более 
простые способы (такие как агрегация unseeded, или что еще лучше, 
оператор Sum). Чтобы дать более реалистичный пример, предположим, что мы
 хотим вычислить частоту появления каждой буквы английского алфавита в 
указанной строке. Простое последовательное решение может выглядеть вот 
так:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">string</span> text = <span style="color: #ba2121;">"Let’s suppose this is a really long string"</span>;</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> letterFrequencies = <span style="color: #008000; font-weight: bold;">new</span> <span style="color: #b00040;">int</span>[<span style="color: #666666;">26</span>];</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">foreach</span> (<span style="color: #b00040;">char</span> c <span style="color: #008000; font-weight: bold;">in</span> text)
{
   <span style="color: #b00040;">int</span> index = <span style="color: #b00040;">char</span>.ToUpper (c) - <span style="color: #ba2121;">'A'</span>;
   <span style="color: #008000; font-weight: bold;">if</span> (index &gt;= <span style="color: #666666;">0</span> &amp;&amp; index &lt;= <span style="color: #666666;">26</span>) letterFrequencies [index]++;
};
</pre>
</div>
<p style="padding-left: 30px;"><span style="color: #008080;">Пример, когда строка будет очень большой - вычисление генома. Тогда "алфавит" должен состоять из букв a, c, g и t.</span></p>
<p>Чтобы распараллелить это, мы должны заменить оператор foreach на 
вызов Parallel.ForEach (что мы рассмотрим в следующей секции), но тут мы
 столкнемся с проблемой конкурентной обработки общего массива. И 
блокировка вокруг доступа к этому массив дала бы безопасность для 
потоков, но убила бы весь потенциал параллелизации.</p>
<p>Агрегат предоставляет опрятное решение. В этом случае в аккумулятор 
это массив, такой же как letterFrequencies из предыдущего примера. Вот 
последовательная версия, использующая Aggregate:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span>[] result =
   text.Aggregate (
      <span style="color: #008000; font-weight: bold;">new</span> <span style="color: #b00040;">int</span>[<span style="color: #666666;">26</span>],                  <span style="color: #408080; font-style: italic;">// Создание "аккумулятора"</span>
      (letterFrequencies, c) =&gt;     <span style="color: #408080; font-style: italic;">// Агрегирование буквы в аккумулятор</span>
      {
         <span style="color: #b00040;">int</span> index = <span style="color: #b00040;">char</span>.ToUpper (c) - <span style="color: #ba2121;">'A'</span>;
         <span style="color: #008000; font-weight: bold;">if</span> (index &gt;= <span style="color: #666666;">0</span> &amp;&amp; index &lt;= <span style="color: #666666;">26</span>) letterFrequencies [index]++;
         <span style="color: #008000; font-weight: bold;">return</span> letterFrequencies;
      });
</pre>
</div>
<p>И теперь параллельная версия, использующая специальную перегрузку PLINQ:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span>[] result =
   text.AsParallel().Aggregate (
      () =&gt; <span style="color: #008000; font-weight: bold;">new</span> <span style="color: #b00040;">int</span>[<span style="color: #666666;">26</span>],            <span style="color: #408080; font-style: italic;">// Создание нового локального аккумулятора</span>
 
      (localFrequencies, c) =&gt;      <span style="color: #408080; font-style: italic;">// Агрегация в локальный аккумулятор</span>
      {
         <span style="color: #b00040;">int</span> index = <span style="color: #b00040;">char</span>.ToUpper (c) - <span style="color: #ba2121;">'A'</span>;
         <span style="color: #008000; font-weight: bold;">if</span> (index &gt;= <span style="color: #666666;">0</span> &amp;&amp; index &lt;= <span style="color: #666666;">26</span>) localFrequencies [index]++;
         <span style="color: #008000; font-weight: bold;">return</span> localFrequencies;
      },
                                    <span style="color: #408080; font-style: italic;">// Агрегация аккумулятора local-&gt;main</span>
      (mainFreq, localFreq) =&gt;
         mainFreq.Zip (localFreq, (f1, f2) =&gt; f1 + f2).ToArray(),
 
      finalResult =&gt; finalResult    <span style="color: #408080; font-style: italic;">// Выполнение последнего действия</span>
   );                               <span style="color: #408080; font-style: italic;">// над конечным результатом.</span>
</pre>
</div>
<p>Обратите внимание, что функция локального накопления мутирует массив 
localFrequencies. Это важная и законная возможность для выполнения 
оптимизации, потому что localFrequencies локален для каждого потока.</p>
<p><a name="ParallelClass"></a>[<strong>Класс Parallel</strong>]</p>
<p>PFX предоставляет базовую форму структурированного параллелизма через три статические метода в классе Parallel:</p>
<p><span style="color: #0000ff;">Parallel.Invoke</span>. Запускает параллельно делегатов из массива.<br><span style="color: #0000ff;">Parallel.For</span>. Выполняет параллельный эквивалент цикла for языка C#.<br><span style="color: #0000ff;">Parallel.ForEach</span>. Выполняет параллельный эквивалент цикла foreach языка C#.</p>
<p>Все три метода блокируют выполнение до момента завершения работы. Как
 с PLINQ, после не обработанного исключения оставшиеся рабочие потоки 
останавливаются после своей текущей итерации и исключение (или 
исключения) выбрасываются обратно в вызывающий код - обернутое в 
AggregateException.</p>
<p><span style="color: #0000ff;"><strong>Parallel.Invoke</strong></span>.
 Parallel.Invoke параллельно запускает в массиве делегатов Action, и 
затем ждет их завершения. Самая простая версия метода определена 
следующим образом:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">static</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Invoke</span> (<span style="color: #008000; font-weight: bold;">params</span> Action[] actions);
</pre>
</div>
<p>Вот так мы можем использовать Parallel.Invoke, чтобы одновременно загрузить две веб-странички:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Parallel.Invoke (
   () =&gt; <span style="color: #008000; font-weight: bold;">new</span> WebClient().DownloadFile (<span style="color: #ba2121;">"http://www.linqpad.net"</span>, <span style="color: #ba2121;">"lp.html"</span>),
   () =&gt; <span style="color: #008000; font-weight: bold;">new</span> WebClient().DownloadFile (<span style="color: #ba2121;">"http://www.jaoo.dk"</span>, <span style="color: #ba2121;">"jaoo.html"</span>));
</pre>
</div>
<p>Внешне это выглядит как удобный ярлычок для создания и ожидания двух 
объектов Task (или асинхронных делегатов). Но здесь есть важное отличие:
 Parallel.Invoke все еще работает эффективно, если Вы передадите в 
массиве миллион делегатов. Это потому, что Parallel.Invoke делит большое
 количество элементов на пакеты, которые присваивает нижележащим задачам
 Task - вместо того, чтобы создавать отдельную Task для каждого 
делегата.</p>
<p>Как и со всеми методами Parallel, Вы действуете самостоятельно при 
сведении вместе результатов обработки. Это означает, что Вам нужно 
учитывать сохранение безопасности потоков. Следующий код, к примеру, не 
потокобезопасный:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> data = <span style="color: #008000; font-weight: bold;">new</span> List&lt; <span style="color: #b00040;">string</span>&gt;();
Parallel.Invoke (
   () =&gt; data.Add (<span style="color: #008000; font-weight: bold;">new</span> WebClient().DownloadString (<span style="color: #ba2121;">"http://www.foo.com"</span>)),
   () =&gt; data.Add (<span style="color: #008000; font-weight: bold;">new</span> WebClient().DownloadString (<span style="color: #ba2121;">"http://www.far.com"</span>)));
</pre>
</div>
<p>Блокировка вокруг этого списка List исправит проблему, хотя 
блокировка создаст узкое место, если у Вас очень большой массив быстро 
исполняемых делегатов. Есть решение лучше - использовать thread-safe 
collection, такую как ConcurrentBag, что идеально для этого случая.</p>
<p>Parallel.Invoke также перегружается для того, чтобы принять объект ParallelOptions:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">static</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Invoke</span> (ParallelOptions options,
                           <span style="color: #008000; font-weight: bold;">params</span> Action[] actions);
</pre>
</div>
<p>Вместе с ParallelOptions Вы можете вставить маркер отмены 
(cancellation token), ограничить максимальную конкуренцию и указать 
пользовательский планировщик задач (custom task scheduler). Маркер 
отмены уместен, когда Вы выполняете (грубо) больше задач, чем имеется в 
наличии ядер: при отмене любые не запущенные делегаты будут заброшены. 
Однако любые уже выполняющиеся делегаты будут продолжать свое выполнение
 до завершения. См. "Отмена запроса (Cancellation)" в [4] для примера 
использования маркеров отмены.</p>
<p><span style="color: #0000ff;"><strong>Parallel.For и Parallel.ForEach</strong></span>.
 Это является эквивалентом циклов for и foreach языка C#, но с каждой 
итерацией тела цикла, выполняющейся параллельно, вместо того, чтобы 
итерации выполнялись последовательно. Вот их (простейшие) сигнатуры:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">static</span> ParallelLoopResult <span style="color: #0000ff;">For</span> (<span style="color: #b00040;">int</span> fromInclusive,
                                      <span style="color: #b00040;">int</span> toExclusive,
                                      Action&lt; <span style="color: #b00040;">int</span>&gt; body)
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">static</span> ParallelLoopResult ForEach&lt; TSource&gt; (IEnumerable&lt; TSource&gt; source,
                                                    Action&lt; TSource&gt; body)
</pre>
</div>
<p>Следующий последовательный цикл for:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">for</span> (<span style="color: #b00040;">int</span> i = <span style="color: #666666;">0</span>; i &lt; <span style="color: #666666;">100</span>; i++)
   Foo (i);
</pre>
</div>
<p>параллелизуется примерно так:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Parallel.For (<span style="color: #666666;">0</span>, <span style="color: #666666;">100</span>, i =&gt; Foo (i));
</pre>
</div>
<p>или еще проще:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Parallel.For (<span style="color: #666666;">0</span>, <span style="color: #666666;">100</span>, Foo);
</pre>
</div>
<p>И следующий последовательный цикл foreach:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">foreach</span> (<span style="color: #b00040;">char</span> c <span style="color: #008000; font-weight: bold;">in</span> <span style="color: #ba2121;">"Hello, world"</span>)
   Foo (c);
</pre>
</div>
<p>параллелизуется наподобие:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Parallel.ForEach (<span style="color: #ba2121;">"Hello, world"</span>, Foo);
</pre>
</div>
<p>Практический пример: если мы импортируем пространство имен 
System.Security.Cryptography namespace, то можем параллельно 
генерировать 6 пар public/private строк ключей:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> keyPairs = <span style="color: #008000; font-weight: bold;">new</span> <span style="color: #b00040;">string</span>[<span style="color: #666666;">6</span>];
 
Parallel.For (<span style="color: #666666;">0</span>, keyPairs.Length,
              i =&gt; keyPairs[i] = RSA.Create().ToXmlString (<span style="color: #008000; font-weight: bold;">true</span>));
</pre>
</div>
<p>Как с Parallel.Invoke, мы можем передать для Parallel.For и 
Parallel.ForEach большое количество обрабатываемых элементов, и они 
будут эффективно разбиты на несколько задач.</p>
<p>Последний запрос также можно реализовать с помощью PLINQ:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">string</span>[] keyPairs =
   ParallelEnumerable.Range (<span style="color: #666666;">0</span>, <span style="color: #666666;">6</span>)
   .Select (i =&gt; RSA.Create().ToXmlString (<span style="color: #008000; font-weight: bold;">true</span>))
   .ToArray();
</pre>
</div>
<p><strong>Сравнение внешних и внутренних циклов</strong>. Parallel.For и
 Parallel.ForEach обычно работают лучше на внешних циклах (outer loop) 
чем на внутренних (inner loop). Это вызвано тем, что с внешним циклом Вы
 предлагаете большие блоки работы для параллелизации, снижая затраты на 
внешнее обслуживание. Параллелизация и внутренних, и внешних циклов 
обычно не требуется. В следующем примере нам понадобилось бы больше 100 
ядер, чтобы извлечь выгоду от внутренней параллелизации:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Parallel.For (<span style="color: #666666;">0</span>, <span style="color: #666666;">100</span>, i =&gt;
{
   Parallel.For (<span style="color: #666666;">0</span>, <span style="color: #666666;">50</span>, j =&gt; Foo (i, j));    <span style="color: #408080; font-style: italic;">// В этом месте последовательное выполнение</span>
});                                          <span style="color: #408080; font-style: italic;">// цикла было бы лучше параллельного.</span>
</pre>
</div>
<p><strong>Индексированный Parallel.ForEach</strong>. Иногда полезно знать индекс итерации цикла. С последовательным foreach это просто:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span> i = <span style="color: #666666;">0</span>;</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">foreach</span> (<span style="color: #b00040;">char</span> c <span style="color: #008000; font-weight: bold;">in</span> <span style="color: #ba2121;">"Hello, world"</span>)
   Console.WriteLine (c.ToString() + i++);
</pre>
</div>
<p>Инкремент общей переменной, однако, не безопасно для потоков в 
контексте параллельного выполнения. Вы должны вместо этого использовать 
следующую версию ForEach:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">static</span> ParallelLoopResult ForEach&lt; TSource&gt; (IEnumerable&lt; TSource&gt; source,
                                                    Action&lt; TSource, ParallelLoopState, <span style="color: #b00040;">long</span>&gt; body)
</pre>
</div>
<p>Мы проигнорируем ParallelLoopState (что будет рассмотрено в следующей
 секции). Сейчас нам интересен третий параметр типа long делегата 
Action, который показывает индекс цикла:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Parallel.ForEach (<span style="color: #ba2121;">"Hello, world"</span>, (c, state, i) =&gt;
{
   Console.WriteLine (c.ToString() + i);
});
</pre>
</div>
<p>Чтобы перевести это в практический контекст, вернемся к проекту 
спеллчекера, который мы писали на основе PLINQ. Следующий код загружает 
словарь для проверки миллиона слов:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">if</span> (!File.Exists (<span style="color: #ba2121;">"WordLookup.txt"</span>))   <span style="color: #408080; font-style: italic;">// Содержит около 150000 слов</span>
   <span style="color: #008000; font-weight: bold;">new</span> <span style="color: #0000ff;">WebClient</span>().DownloadFile (
      <span style="color: #ba2121;">"http://www.albahari.com/ispell/allwords.txt"</span>, <span style="color: #ba2121;">"WordLookup.txt"</span>);
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> wordLookup = <span style="color: #008000; font-weight: bold;">new</span> HashSet&lt; <span style="color: #b00040;">string</span>&gt; (
   File.ReadAllLines (<span style="color: #ba2121;">"WordLookup.txt"</span>),
      StringComparer.InvariantCultureIgnoreCase);
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> random = <span style="color: #008000; font-weight: bold;">new</span> Random();</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">string</span>[] wordList = wordLookup.ToArray();
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">string</span>[] wordsToTest = Enumerable.Range (<span style="color: #666666;">0</span>, <span style="color: #666666;">1000000</span>)
   .Select (i =&gt; wordList [random.Next (<span style="color: #666666;">0</span>, wordList.Length)])
   .ToArray();
 
wordsToTest [<span style="color: #666666;">12345</span>] = <span style="color: #ba2121;">"woozsh"</span>;     <span style="color: #408080; font-style: italic;">// Ввод нескольких ошибок</span>
wordsToTest [<span style="color: #666666;">23456</span>] = <span style="color: #ba2121;">"wubsie"</span>;     <span style="color: #408080; font-style: italic;">// орфографии.</span>
</pre>
</div>
<p>Мы можем выполнить проверку орфографии нашего массива wordsToTest с 
использованием индексированной версии Parallel.ForEach следующим 
образом:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> misspellings = <span style="color: #008000; font-weight: bold;">new</span> ConcurrentBag&lt; Tuple&lt; <span style="color: #b00040;">int</span>,<span style="color: #b00040;">string</span>&gt;&gt;();
 
Parallel.ForEach (wordsToTest, (word, state, i) =&gt;
{
   <span style="color: #008000; font-weight: bold;">if</span> (!wordLookup.Contains (word))
      misspellings.Add (Tuple.Create ((<span style="color: #b00040;">int</span>) i, word));
});
</pre>
</div>
<p>Обратите внимание, что мы должны были сопоставить результаты в 
thread-safe коллекции: из-за этой необходимости этот код имеет 
недостаток по сравнению с кодом на PLINQ. Достоинство PLINQ в том, что 
мы избегаем цены применения индексированного оператора запроса Select - 
который менее эффективный, чем индексированный ForEach.</p>
<p><strong>ParallelLoopState: ранний выход из циклов</strong>. Из-за 
того, что тело цикла в параллельном For или ForEach это делегат, Вы не 
можете выполнить ранний выход из цикла с помощью оператора break. Вместо
 этого Вы должны вызвать Break или Stop на объекте ParallelLoopState:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">class</span> <span style="color: #0000ff; font-weight: bold;">ParallelLoopState</span>
{
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Break</span>();
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Stop</span>();
 
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #b00040;">bool</span> IsExceptional { <span style="color: #008000; font-weight: bold;">get</span>; }
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #b00040;">bool</span> IsStopped { <span style="color: #008000; font-weight: bold;">get</span>; }
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #b00040;">long?</span> LowestBreakIteration { <span style="color: #008000; font-weight: bold;">get</span>; }
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #b00040;">bool</span> ShouldExitCurrentIteration { <span style="color: #008000; font-weight: bold;">get</span>; }
}
</pre>
</div>
<p>Получить ParallelLoopState просто: все версии For и ForEach 
перегружены чтобы принять тела цикла типа Action&lt; TSource, 
ParallelLoopState&gt;. Распараллелим вот это:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">foreach</span> (<span style="color: #b00040;">char</span> c <span style="color: #008000; font-weight: bold;">in</span> <span style="color: #ba2121;">"Hello, world"</span>)
   <span style="color: #008000; font-weight: bold;">if</span> (c == <span style="color: #ba2121;">','</span>)
      <span style="color: #008000; font-weight: bold;">break</span>;
   <span style="color: #008000; font-weight: bold;">else</span>
      Console.Write (c);
</pre>
</div>
<p>следующим образом:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Parallel.ForEach (<span style="color: #ba2121;">"Hello, world"</span>, (c, loopState) =&gt;
{
   <span style="color: #008000; font-weight: bold;">if</span> (c == <span style="color: #ba2121;">','</span>)
      loopState.Break();
   <span style="color: #008000; font-weight: bold;">else</span>
      Console.Write (c);
});
</pre>
</div>
<p>Выведенный результат:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #000000; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #ffffff;">Hlloe
</span></pre>
</div>
<p>Можно увидеть из выведенного результата "Hlloe", что тела цикла могут
 выполняться в случайном порядке. Кроме этого отличия, вызов Break 
приведет к тому, что как минимум одинаковые элементы в цикле будут 
выполняться последовательно: этот пример всегда выведет как минимум 
буквы H, e, l, l и o в некотором порядке. Вызов Stop отличается от 
вызова Break тем, что принуждает все потоки завершиться сразу после их 
текущей итерации. В нашем примере вызов Stop дал бы нам подмножество 
букв H, e, l, l и o, если другой поток отстает. Вызов Stop полезно 
сделать, когда Вы обнаружили то, что ищете, или когда что-то пошло не 
так, и мы не хотим смотреть на результаты.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Методы 
Parallel.For и Parallel.ForEach возвратят объект ParallelLoopResult, 
который публикует свойства IsCompleted и LowestBreakIteration. Они 
скажут Вам, доработал ли цикл до завершения, и если нет, то на какой 
итерации цикл был оборван.</span></p>
<p style="padding-left: 30px;"><span style="color: #008080;">Если LowestBreakIteration вернет null, то это означает, что Вы вызвали на цикле Stop (вместо Break).</span></p>
<p>Если тело Вашего цикла длинное, то Вы можете захотеть, чтобы другие 
потоки остановили выполнение внутри своего тела в случае раннего вызова 
Break или Stop. Вы можете выполнить это опросом свойства 
ShouldExitCurrentIteration в различных местах своего кода; оно станет 
true сразу после Stop - или почти сразу после Break.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">ShouldExitCurrentIteration
 также станет true после запроса отмены (cancellation request) - или 
если в цикле выброшено исключение.</span></p>
<p>IsExceptional позволит Вам узнать, произошло ли исключение в другом 
потоке. Любое не обработанное исключение приведет к остановке цикла 
после каждой текущей итерации потока: чтобы избежать этого, Вы должны 
явно обработать исключения в своем коде.</p>
<p><strong>Оптимизация с локальными переменными</strong>. Parallel.For и
 Parallel.ForEach предоставляют набор перегрузок, реализующих аргумент 
обычного типа с именем TLocal. Эти перегрузки разработаны, чтобы помочь 
Вам оптимизировать слияния данных в циклах с интенсивными итерациями. 
Самый простой пример:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">static</span> ParallelLoopResult For &lt; TLocal&gt; (
   <span style="color: #b00040;">int</span> fromInclusive,
   <span style="color: #b00040;">int</span> toExclusive,
   Func &lt; TLocal&gt; localInit,  Func &lt; <span style="color: #b00040;">int</span>, ParallelLoopState, TLocal, TLocal&gt; body,
   Action &lt; TLocal&gt; localFinally);
</pre>
</div>
<p>Эти методы редко нужны на практике, потому что их целевые сценарии 
обычно обслуживаются PLINQ (что удачнее, потому что синтаксис этих 
перегрузок пугает).</p>
<p>В сущности, проблема заключается в следующем: предположим, что мы 
хотим сложить квадратные корни чисел от 1 до 10000000. Вычисление 10 
миллионов квадратных корней просто параллелизуется, но суммирование их 
значений проблематично, потому что мы должны реализовать блокировку 
вокруг обновления результата:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">object</span> locker = <span style="color: #008000; font-weight: bold;">new</span> <span style="color: #b00040;">object</span>();</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">double</span> total = <span style="color: #666666;">0</span>;
Parallel.For (<span style="color: #666666;">1</span>, <span style="color: #666666;">10000000</span>,
              i =&gt; { <span style="color: #008000; font-weight: bold;">lock</span> (locker) total += Math.Sqrt (i); });
</pre>
</div>
<p>Выигрыш от параллелизации нивелируется ценой получения 10 миллионов блокировок плюс результирующая блокировка.</p>
<p>Однако реально нам не нужны эти 10 миллионов блокировок. Вообразите 
команду волонтеров, собирающих большой объем мусора. Если бы все рабочие
 использовали бы одну мусорную корзину, то перемещения рабочих и их 
конкуренция за корзину сделали бы общий процесс сбора мусора 
экстремально не эффективным. Очевидное решение - дать каждому рабочему 
по "локальному" мусорному ведру, которое он может по случаю опорожнять в
 общую корзину.</p>
<p>TLocal-версии для For и ForEach работают точно по такому принципу. 
Волонтерами тут служат внутренние рабочие потоки, и локальное значение 
представляет местное ведерко мусора. В случае применения Parallel для 
такой работы Вы должны передать ему двух дополнительных делегатов, чтобы
 показать:</p>
<p><strong>1</strong>. Как инициализировать новое локальное значение.<br><strong>2</strong>. Как комбинировать локальную агрегацию с главным значением.</p>
<p>Дополнительно вместо тела делегата, возвращающего void, он должен 
возвращать новый агрегат для этого локального значения. Вот наш 
переработанный пример:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">object</span> locker = <span style="color: #008000; font-weight: bold;">new</span> <span style="color: #b00040;">object</span>();</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">double</span> grandTotal = <span style="color: #666666;">0</span>;
 
Parallel.For (<span style="color: #666666;">1</span>, <span style="color: #666666;">10000000</span>, 
   () =&gt; <span style="color: #666666;">0.0</span>,                       <span style="color: #408080; font-style: italic;">// Инициализация локального значения.</span>
   (i, state, localTotal) =&gt;        <span style="color: #408080; font-style: italic;">// Делегат тела цикла. Обратите внимание, что он возвращает</span>
      localTotal + Math.Sqrt (i),   <span style="color: #408080; font-style: italic;">// новое общее локальное значение localTotal.</span>
 
   localTotal =&gt;                                   <span style="color: #408080; font-style: italic;">// Добавление локального значения</span>
      { <span style="color: #008000; font-weight: bold;">lock</span> (locker) grandTotal += localTotal; }  <span style="color: #408080; font-style: italic;">// к общему значению (с блокировкой).</span>
);
</pre>
</div>
<p>Мы все еще должны применить блокировку, то теперь только вокруг 
агрегации локального значения к общему. Это делает весь процесс 
кардинально эффективнее.</p>
<p>Как было замечено ранее, PLINQ часто хорошо подходит для подобных 
задач. Наш пример мог бы очень просто параллелится с помощью PLINQ 
следующим образом:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">ParallelEnumerable.Range(<span style="color: #666666;">1</span>, <span style="color: #666666;">10000000</span>)
                  .Sum (i =&gt; Math.Sqrt (i))
</pre>
</div>
<p>Обратите внимание, что здесь мы применили ParallelEnumerable, чтобы 
принудительно задать разделение по диапазону (range partitioning): для 
нашего примера это улучшает производительность, потому что все числа 
обрабатываются по времени примерно одинаково.</p>
<p>В более сложных сценариях Вы можете использовать оператор Aggregate 
запроса LINQ вместо Sum. Если Вы предоставили функцию локального 
начального значения (local seed factory), то ситуация была бы похожей на
 предоставление локального значения функции с циклом Parallel.For.</p>
<p><a name="TaskParallelism"></a>[<strong>Параллелизм задач</strong>]</p>
<p>Task Parallelism (параллелизм задач) это метод параллелизации самого 
низкого уровня с помощью PFX. В System.Threading.Tasks namespace для 
этого определены классы:</p>
<table cellspacing="1" cellpadding="3" border="0" bgcolor="#8cacbb">
<tbody>
<tr style="background-color: #dee7ec;">
<td><b>Класс</b></td>
<td><b>Назначение</b></td>
</tr>
<tr style="background-color: #ffffff;">
<td>Task</td>
<td>Для управления единицей работы.</td>
</tr>
<tr style="background-color: #ffffff;">
<td>Task&lt; TResult&gt;</td>
<td>Для управления единицей работы с возвратом значения.</td>
</tr>
<tr style="background-color: #ffffff;">
<td>TaskFactory</td>
<td>Для создания задач.</td>
</tr>
<tr style="background-color: #ffffff;">
<td>TaskFactory&lt; TResult&gt;</td>
<td>Для создания задач и задач-продолжений с тем же самым возвращаемым значением.</td>
</tr>
<tr style="background-color: #ffffff;">
<td>TaskScheduler</td>
<td>Для управления планированием запуска задач.</td>
</tr>
<tr style="background-color: #ffffff;">
<td>TaskCompletionSource</td>
<td>Для ручного управления рабочим процессом задач.</td>
</tr>
</tbody>
</table>
<p>В сущности задача (task) это облегченный объект для управления 
распараллеленной единицей работы. Task позволяет избежать накладных 
расходов на запуск выделенного потока с помощью использования пула 
потоков (CLR thread pool): это тот же самый пул потоков, используемый 
ThreadPool.QueueUserWorkItem, что появилось в CLR 4.0, чтобы эффективно 
работать с Tasks (и обычно более эффективно).</p>
<p>Tasks можно использовать всякий раз, когда Вы хотите что-то выполнить
 параллельно. Однако это заточено для задействования нескольких ядер: 
фактически класс Parallel и запросы PLINQ внутренне построены на 
конструкциях параллелизма задач.</p>
<p>Tasks делают больше, чем просто дают простой и эффективный способ 
работы через пул потоков. Они также предоставляют некоторые мощные 
функции для управления единицами работы, включая следующее:</p>
<p>• Настройка планирования выполнения задач (task scheduling).<br>• Организация взаимосвязи родительский/дочерний (parent/child), когда одна task запускается из другой.<br>• Реализация совместной отмены (cooperative cancellation).<br>• Ожидание набора задач - без конструкции сигнализации.<br>• Подключение задачи (задач) продолжения (continuation).<br>• Планирование продолжения на основе нескольких предшествующих задач.<br>• Распространение исключений на родительские задачи, задачи продолжения и потребители данных задач (task consumers).</p>
<p>Задачи также реализуют локальные рабочие запросы (local work queues).
 Это оптимизация, которая позволяет Вам эффективно создавать множество 
быстро выполняющихся дочерних задач без возникновения накладных расходов
 на конкуренцию, которая иначе возникла бы с одной рабочей очередью.</p>
<p style="padding-left: 30px;"><span style="color: #800000;">Библиотека 
TLP (Task Parallel Library) позволяет Вам создать сотни (или даже 
тысячи) задач с минимальными затратами. Но если Вы хотите создать 
миллионы задач, то понадобится разделить эти задачи на большие блоки 
работы, чтобы сохранить эффективность. Класс Parallel и PLINQ делают это
 автоматически.</span></p>
<p style="padding-left: 30px;"><span style="color: #008080;">Visual 
Studio 2010 предоставляет новое окно для мониторинга задач (Debug -&gt; 
Window -&gt; Parallel Tasks). Это эквивалентно окну Threads, но только 
для задач. Окно Parallel Stacks также предоставляет специальный режим 
просмотра отладочной информации для задач.</span></p>
<p><strong>Создание и запуск задач</strong>. В описании пула потоков [2]
 уже обсуждалось, что Вы можете создать и запустить Task вызовом 
Task.Factory.StartNew с передачей делегата в Action:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task.Factory.StartNew (() =&gt; Console.WriteLine (<span style="color: #ba2121;">"Hello from a task!"</span>));
</pre>
</div>
<p>В обычной версии Task&lt; TResult&gt; (подкласс Task) позволяет Вам получить данные из задачи после её завершения:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task&lt; <span style="color: #b00040;">string</span>&gt; task = Task.Factory.StartNew&lt;<span style="color: #b00040;">string</span>&gt; (() =&gt;   <span style="color: #408080; font-style: italic;">// Запуск задачи</span>
{
   <span style="color: #008000; font-weight: bold;">using</span> (<span style="color: #b00040;">var</span> wc = <span style="color: #008000; font-weight: bold;">new</span> System.Net.WebClient())
      <span style="color: #008000; font-weight: bold;">return</span> wc.DownloadString (<span style="color: #ba2121;">"http://www.linqpad.net"</span>);
});
 
RunSomeOtherMethod();         <span style="color: #408080; font-style: italic;">// Мы можем делать другую работу параллельно...</span>
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">string</span> result = task.Result;  <span style="color: #408080; font-style: italic;">// Ожидание завершения задачи и получение результата.</span>
</pre>
</div>
<p>Task.Factory.StartNew создает и запускает задачу за один шаг. Вы 
можете разделить эти операции, если сначала инстанциировать объект Task,
 и затем вызвать Start:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> task = <span style="color: #008000; font-weight: bold;">new</span> Task (() =&gt; Console.Write (<span style="color: #ba2121;">"Hello"</span>));
...
task.Start();
</pre>
</div>
<p>Задача, которую Вы создаете таким способом, можно также запустить 
синхронно (в том же потоке) вызовом RunSynchronously вместо Start.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Вы можете отслеживать состояние выполнения задачи через её свойство Status.</span></p>
<p><strong>Указание состояния объекта</strong>. Когда инстанциируется 
задача, или вызывается Task.Factory.StartNew, можно указать объект 
состояния (state object), который передается целевому методу. Это 
полезно, если Вы хотели бы вызвать метод напрямую вместо использования 
lambda-выражения:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">static</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Main</span>()
{
   <span style="color: #b00040;">var</span> task = Task.Factory.StartNew (Greet, <span style="color: #ba2121;">"Hello"</span>);
   task.Wait();   <span style="color: #408080; font-style: italic;">// Ожидание завершения задачи.</span>
}
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">static</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Greet</span> (<span style="color: #b00040;">object</span> state) { Console.Write (state); }    <span style="color: #408080; font-style: italic;">// Hello</span>
</pre>
</div>
<p>Учитывая, что у нас в C# есть lambda-выражения, можно ввести объект 
состояния для лучшего использования, когда задаче назначается 
осмысленное имя. Мы можем тогда использовать AsyncState для опроса этого
 имени:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">static</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Main</span>()
{
   <span style="color: #b00040;">var</span> task = Task.Factory.StartNew (state =&gt; Greet (<span style="color: #ba2121;">"Hello"</span>), <span style="color: #ba2121;">"Greeting"</span>);
   Console.WriteLine (task.AsyncState);      <span style="color: #408080; font-style: italic;">// Greeting</span>
   task.Wait();
}
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">static</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Greet</span> (<span style="color: #b00040;">string</span> message) { Console.Write (message); }
</pre>
</div>
<p>Visual Studio отобразит AsyncState каждой задачи в окне Parallel 
Tasks, так что имея понятное имя задачи, можно значительно упростить 
отладку.</p>
<p><strong>TaskCreationOptions</strong>. Вы можете подстроить выполнение
 задачи, указав перечисление TaskCreationOptions, когда вызываете 
StartNew (или когда инстанциируете задачу Task). TaskCreationOptions это
 перечисление флагов, содержащее следующие (комбинируемые по ИЛИ) 
значения:</p>
<p><span style="color: #0000ff;">LongRunning</span><br><span style="color: #0000ff;">PreferFairness</span><br><span style="color: #0000ff;">AttachedToParent</span></p>
<p>LongRunning советует планировщику выделить для задачи отдельный 
поток. Это выгодно для долго работающих задач, потому что иначе может 
образоваться пожирающая ресурсы очередь, с принудительной приостановкой 
быстро выполняющихся задач на неразумно долгое время. LongRunning также 
хорошо применять для блокирующихся задач.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Проблема 
постановки задач в очередь возникает потому, что планировщик задач 
обычно пытается сохранить достаточное количество одновременно активных 
задач на потоках, чтобы поддерживать занятость каждого ядра CPU. 
Ограничение нагрузки CPU слишком большим количеством активных потоков 
позволяет избежать деградации производительности, которая произошла бы, 
если бы операционная система была бы вынуждена тратить слишком много 
времени на обслуживание тиков (expensive time slicing) и переключение 
контекста (context switching).</span></p>
<p>PreferFairness говорит планировщику попытаться обеспечить условия, 
чтобы выполнение задач было запланировано в том же порядке, в каком они 
были запущены. Обычно порядок запуска задач могло бы быть другим, потому
 что имеется внутренняя оптимизация планирования задач с использованием 
локальных рабочих очередей. Эта оптимизация дает практическую выгоду с 
очень маленькими (четко очерченными) задачами.</p>
<p>AttachedToParent используется для создания дочерних задач.</p>
<p><strong>Дочерние задачи</strong>. Когда одна задача запускает другую,
 Вы опционально можете установить взаимодействие parent-child путем 
указания TaskCreationOptions.AttachedToParent:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task parent = Task.Factory.StartNew (() =&gt;
{
   Console.WriteLine (<span style="color: #ba2121;">"I am a parent"</span>);
 
   Task.Factory.StartNew (() =&gt;     <span style="color: #408080; font-style: italic;">// Отсоединенная (т. е. родительская) задача</span>
   {
      Console.WriteLine (<span style="color: #ba2121;">"I am detached"</span>);
   });
 
   Task.Factory.StartNew (() =&gt;     <span style="color: #408080; font-style: italic;">// Дочерняя задача (child)</span>
   {
      Console.WriteLine (<span style="color: #ba2121;">"I am a child"</span>);
   }, TaskCreationOptions.AttachedToParent);
});
</pre>
</div>
<p>Особенность дочерних (child) задач в том, что когда Вы ждете 
завершения родительской (parent) задачи, то она ждет, пока завершатся 
все её дочерние задачи. Это может быть в частности полезно, когда 
дочерняя задача является продолжением (continuation), как мы скоро 
увидим.</p>
<p><strong>Ожидание на задачах</strong>. Вы можете явно ждать завершения задачи двумя способами:</p>
<p>• Вызовом её метода Wait (опционально с таймаутом)<br>• Доступом к её свойству Result (в случае Task&lt; TResult&gt;)</p>
<p>Вы можете также ждать на нескольких задачах сразу с помощью 
статических методов Task.WaitAll (ждет завершения всех указанных задач) и
 Task.WaitAny (ждет завершения только одной задачи).</p>
<p>WaitAll работает подобно ожиданию каждой задачи по отдельности, но 
более эффективно тем, что это требует (самое большее) только одного 
переключения контекста. Также если одна или большее количество задач 
выбросят необработанное исключение, WaitAll все еще будет ждать каждую 
задачу - и затем перебросить одно AggregateException, в котором 
аккумулированы исключения от каждой задачи, в которой такое исключение 
произошло. Это эквивалентно следующему:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// Предположим, что t1, t2 и t3 это задач:</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> exceptions = <span style="color: #008000; font-weight: bold;">new</span> List&lt; Exception&gt;();</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">try</span> { t1.Wait(); } <span style="color: #008000; font-weight: bold;">catch</span> (AggregateException ex) { exceptions.Add (ex); }</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">try</span> { t2.Wait(); } <span style="color: #008000; font-weight: bold;">catch</span> (AggregateException ex) { exceptions.Add (ex); }</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">try</span> { t3.Wait(); } <span style="color: #008000; font-weight: bold;">catch</span> (AggregateException ex) { exceptions.Add (ex); }</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">if</span> (exceptions.Count &gt; <span style="color: #666666;">0</span>) <span style="color: #008000; font-weight: bold;">throw</span> <span style="color: #008000; font-weight: bold;">new</span> AggregateException (exceptions);
</pre>
</div>
<p>Вызов WaitAny эквивалентно ожиданию ManualResetEventSlim, что сигнализируется каждой завершающейся задачей.</p>
<p>Так же, как и таймаут, Вы можете передать маркер отмены (cancellation
 token) методам Wait: это позволит Вам отменить ожидание, а не саму 
задачу.</p>
<p><strong>Задачи обработки исключений</strong>. Когда Вы хотите ждать 
завершения задачи (вызовом её метода Wait или доступом к её свойству 
Result), то любые не обработанные исключения перебрасываются в 
вызывающий код, обернутые в объект AggregateException. Это обычно дает 
возможность избегать необходимости написания кода обработки исключений в
 теле задач; вместо этого мы можем сделать следующее:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span> x = <span style="color: #666666;">0</span>;
Task&lt; <span style="color: #b00040;">int</span>&gt; calc = Task.Factory.StartNew (() =&gt; <span style="color: #666666;">7</span> / x);</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">try</span>
{
   Console.WriteLine (calc.Result);
}</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">catch</span> (AggregateException aex)
{
   Console.Write (aex.InnerException.Message);  <span style="color: #408080; font-style: italic;">// Попытка поделить на 0</span>
}
</pre>
</div>
<p>Вам все еще нужно реализовать обработку исключений для отключенных 
автономных задач (не порожденные задачи, на которых нет ожидания) чтобы 
предотвратить возникновение необработанного и отказа всего приложения, 
когда задача выпадает из процесса и убирается сборщиком мусора (к этой 
ситуации относится следующее замечание). То же самое относится к 
задачам, на которых происходит ожидание с таймаутом, потому что 
исключение, выброшенное по истечении интервала таймаута, будет иначе "не
 обработанным" (unhandled).</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Статическое
 событие TaskScheduler.UnobservedTaskException предоставляет последний 
шанс обработать необработанные исключения задачи. Путем обработки этого 
события Вы можете перехватить исключения задачи, которые иначе могут 
привести к падению приложения - и обеспечить свою собственную логику 
решить проблему исключения (или записать в лог информацию об 
исключении).</span></p>
<p>Для порожденных задач ожидание родителя неявно приводит к ожиданию дочерних задач - и тогда всплывут дочерние исключения:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">TaskCreationOptions atp = TaskCreationOptions.AttachedToParent;</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> parent = Task.Factory.StartNew (() =&gt; 
{
   Task.Factory.StartNew (() =&gt;     <span style="color: #408080; font-style: italic;">// Сын</span>
   {
      Task.Factory.StartNew (() =&gt; { <span style="color: #008000; font-weight: bold;">throw</span> <span style="color: #008000; font-weight: bold;">null</span>; }, atp);      <span style="color: #408080; font-style: italic;">// Внук</span>
   }, atp);
});
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// Следующий вызов выбросит исключение NullReferenceException (обернутое</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// вложением в AggregateExceptions):</span>
parent.Wait();
</pre>
</div>
<p style="padding-left: 30px;"><span style="color: #008080;">Интересно, 
что если Вы проверите свойство задачи Exception после того, как она 
выбросила исключение, то акт чтения этого свойства предотвратит 
последующее падение приложения. Рациональность такого подхода в том, что
 разработчики PFX не хотят, чтобы Вы игнорировали исключения - пока Вы 
не подтвердите их каким-то способом, они Вас не накажут завершением 
программы.</span></p>
<p style="padding-left: 30px;"><span style="color: #800000;">Не 
обработанное исключение на задаче не приведет к немедленному завершению 
приложения: вместо этого завершение будет задержано до тех пор, пока 
сборщик мусора не захватит задачу и не вызовет её "завершатель". 
Завершение откладывается, потому что нельзя знать точно, хотите ли Вы 
вызвать Wait или проверить свойство Result или Exception до момента, 
когда задача будет уничтожена сборщиком мусора. Эта задержка может 
иногда ввести Вас в заблуждение по поводу источника ошибки (хотя 
отладчик Visual Studio может помочь, если Вы разрешите точку останова на
 исключениях first-chance).</span></p>
<p>Как мы увидим, альтернативная стратегия разборок с исключениями состоит в использовании продолжений (continuations).</p>
<p><strong>Отмена задач</strong>. Вы можете опционально передать маркер 
отмены (cancellation token), когда запускаете задачу. Это позволит Вам 
отменить задачи через шаблон совместной отмены (cooperative 
cancellation), как описывалось ранее:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> cancelSource = <span style="color: #008000; font-weight: bold;">new</span> CancellationTokenSource();
CancellationToken token = cancelSource.Token;
 
Task task = Task.Factory.StartNew (() =&gt; 
{
   <span style="color: #408080; font-style: italic;">// Тут что-то делаем...</span>
   token.ThrowIfCancellationRequested();     <span style="color: #408080; font-style: italic;">// Проверка запроса на отмену</span>
   <span style="color: #408080; font-style: italic;">// Тут что-то делаем...</span>
}, token);
...
cancelSource.Cancel();
</pre>
</div>
<p>Чтобы детектировать отмененную задачу, захватите (catch) исключение 
AggregateException, и проверьте внутреннее исключение следующим образом:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">try</span> 
{
   task.Wait();
}</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">catch</span> (AggregateException ex)
{
   <span style="color: #008000; font-weight: bold;">if</span> (ex.InnerException <span style="color: #008000; font-weight: bold;">is</span> OperationCanceledException)
      Console.Write (<span style="color: #ba2121;">"Задача отменена!"</span>);
}
</pre>
</div>
<p style="padding-left: 30px;"><span style="color: #008080;">Если Вы 
хотите явно выбросить исключение OperationCanceledException (вместо 
вызова token.ThrowIfCancellationRequested), то должны передать маркер 
отмены в конструктор OperationCanceledException. Если Вы не сделаете 
этого, задача не закончится со статусом TaskStatus.Canceled, и не 
сработают продолжения OnlyOnCanceled.</span></p>
<p>Если задача отменена перед её запуском, то не будет запланировано её 
выполнение - вместо этого на задаче будет немедленно выброшено 
исключение OperationCanceledException.</p>
<p>Из-за того, что маркеры отмены (cancellation tokens) распознаются 
другим API, Вы можете передать их в другие конструкции и отмены будут 
распространены беспрепятственно:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> cancelSource = <span style="color: #008000; font-weight: bold;">new</span> CancellationTokenSource();
CancellationToken token = cancelSource.Token;
 
Task task = Task.Factory.StartNew (() =&gt;
{
   <span style="color: #408080; font-style: italic;">// Передача нашего маркера отмены в запрос PLINQ:</span>
   <span style="color: #b00040;">var</span> query = someSequence.AsParallel().WithCancellation (token)...
   ... перечисление запроса ...
});
</pre>
</div>
<p>Вызов Cancel на cancelSource в этом примере отменит запрос PLINQ, 
который выбросит исключение OperationCanceledException на теле задачи, 
которое тогда отменит задачу.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Маркеры 
отмены, которые Вы можете передать в такие методы, как Wait и 
CancelAndWait, позволяют Вам отменить операцию ожидания, но не саму 
задачу.</span></p>
<p><a name="Continuations"></a></p>
<p><strong>Продолжения</strong> (continuations). Иногда полезно 
запустить задачу сразу после того, как другая завершится (или в ней 
произойдет ошибка/исключение). Метод ContinueWith в классе Task делает 
именно это:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task task1 = Task.Factory.StartNew (() =&gt; Console.Write (<span style="color: #ba2121;">"antecedant.."</span>));
Task task2 = task1.ContinueWith (ant =&gt; Console.Write (<span style="color: #ba2121;">"..continuation"</span>));
</pre>
</div>
<p>Как только task1 (предшествующая задача) завершится, потерпит сбой 
или будет отменена, автоматически запустится task2 (задача продолжения, 
continuation). Если task1 завершится перед тем, как запустится вторая 
строка, то выполнение task2 будет запланировано на выполнение правильным
 способом. Аргумент ant, переданный в lambda-выражение задачи 
продолжения, является ссылкой на предшествующую задачу.</p>
<p>Наш пример продемонстрировал простейший вид продолжения, и функционально он делает следующее:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task task = Task.Factory.StartNew (() =&gt;
{
   Console.Write (<span style="color: #ba2121;">"antecedent.."</span>);
   Console.Write (<span style="color: #ba2121;">"..continuation"</span>);
});
</pre>
</div>
<p>Однако алгоритм, основанный на продолжении, более гибкий, потому что 
Вы могли бы сначала ожидать на task1, и затем ожидать на task2. Это в 
частности полезно, если task1 возвращает данные.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Другое 
(более тонкое) различие в том, что по умолчанию предшествующая задача и 
задача продолжения могут быть выполнены в разных потоках. Вы можете 
принудительно запустить их в одном потоке, если укажете 
TaskContinuationOptions.ExecuteSynchronously, когда вызываете 
ContinueWith: это может улучшить производительность в случае очень 
частых мелких продолжений путем уменьшения косвенных обращений.</span></p>
<p><strong>Продолжения и Task&lt; TResult&gt;</strong>. Как и обычные 
задачи, продолжения могут быть типа Task&lt; TResult&gt; с возвратом 
данных. В следующем примере мы вычисляем Math.Sqrt(8*2) с использованием
 поставленных в цепочку задач, и затем отображаем результат:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task.Factory.StartNew&lt; <span style="color: #b00040;">int</span>&gt; (() =&gt; <span style="color: #666666;">8</span>)
   .ContinueWith (ant =&gt; ant.Result * <span style="color: #666666;">2</span>)
   .ContinueWith (ant =&gt; Math.Sqrt (ant.Result))
   .ContinueWith (ant =&gt; Console.WriteLine (ant.Result));   <span style="color: #408080; font-style: italic;">// 4</span>
</pre>
</div>
<p>Наш пример возможно излишне упрощен; в реальной жизни эти 
lambda-выражения могли бы вызывать функции с интенсивными вычислениями.</p>
<p><strong>Продолжения и исключения</strong>. Задача продолжения 
(continuation) может узнать, произошло ли исключение в через свойство 
Exception предшествующей задачи (antecedent task). Следующий код запишет
 в консоль подробности исключения NullReferenceException:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task task1 = Task.Factory.StartNew (() =&gt; { <span style="color: #008000; font-weight: bold;">throw</span> <span style="color: #008000; font-weight: bold;">null</span>; });
Task task2 = task1.ContinueWith (ant =&gt; Console.Write (ant.Exception));
</pre>
</div>
<p style="padding-left: 30px;"><span style="color: #800000;">Если 
antecedent-задача выбросила исключение continuation-не опросила свойство
 Exception antecedent-задачи (и на antecedent-задаче нет ожидания), то 
исключение считается не обработанным и приложение завершится по ошибке 
(если не будет обработано исключение через 
TaskScheduler.UnobservedTaskException).</span></p>
<p>Безопасный шаблон - перебросить исключения antecedent-задачи. Пока 
происходит ожидание на continuation-задаче, исключение будет 
распространено и переброшено на ожидающий код:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task continuation = Task.Factory.StartNew     (()  =&gt; { <span style="color: #008000; font-weight: bold;">throw</span> <span style="color: #008000; font-weight: bold;">null</span>; })
                                .ContinueWith (ant =&gt;
   {
      <span style="color: #008000; font-weight: bold;">if</span> (ant.Exception != <span style="color: #008000; font-weight: bold;">null</span>) <span style="color: #008000; font-weight: bold;">throw</span> ant.Exception;    <span style="color: #408080; font-style: italic;">// Продолжение обработки...</span>
   });
 
continuation.Wait();    <span style="color: #408080; font-style: italic;">// Исключение теперь перебрасывается обратно в вызывающий код</span>
</pre>
</div>
<p>Другой способ разобраться с исключениями - указать другие 
continuation-задачи для результатов с исключениями, отличающиеся от 
continuation-задач для нормального завершения. Это решается через 
TaskContinuationOptions:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task task1 = Task.Factory.StartNew (() =&gt; { <span style="color: #008000; font-weight: bold;">throw</span> <span style="color: #008000; font-weight: bold;">null</span>; });
 
Task error = task1.ContinueWith (ant =&gt; Console.Write (ant.Exception),
                                 TaskContinuationOptions.OnlyOnFaulted);
 
Task ok = task1.ContinueWith (ant =&gt; Console.Write (<span style="color: #ba2121;">"Success!"</span>),
                              TaskContinuationOptions.NotOnFaulted);
</pre>
</div>
<p>Как мы увидим позже, этот шаблон в частности полезен совместно с дочерними задачами.</p>
<p>Следующий метод расширения "глотает" не обработанные исключения задачи:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">static</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">IgnoreExceptions</span> (<span style="color: #008000; font-weight: bold;">this</span> Task task)
{
   task.ContinueWith (t =&gt; { <span style="color: #b00040;">var</span> ignore = t.Exception; },
      TaskContinuationOptions.OnlyOnFaulted);
</pre>
</div>
<p>Вот, как это использовалось бы (это можно было бы улучшить путем добавления кода для записи в лог информации исключения):</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task.Factory.StartNew (() =&gt; { <span style="color: #008000; font-weight: bold;">throw</span> <span style="color: #008000; font-weight: bold;">null</span>; }).IgnoreExceptions();
</pre>
</div>
<p><strong>Продолжения и дочерние задачи</strong>. Мощная функция 
continuation-задач в том, что они начинаются только тогда, когда все 
дочерние задачи завершились. Начиная с этого места любые выброшенные 
дочерними задачами исключения перенаправляются в continuation-задачу.</p>
<p>В следующем примере мы запустим 3 дочерние задачи, каждая из них 
выбрасывает NullReferenceException. Затем мы перехватываем эти все 
исключения за один раз через continuation родительской задачи:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">TaskCreationOptions atp = TaskCreationOptions.AttachedToParent;
Task.Factory.StartNew (() =&gt;
{
   Task.Factory.StartNew (() =&gt; { <span style="color: #008000; font-weight: bold;">throw</span> <span style="color: #008000; font-weight: bold;">null</span>; }, atp);
   Task.Factory.StartNew (() =&gt; { <span style="color: #008000; font-weight: bold;">throw</span> <span style="color: #008000; font-weight: bold;">null</span>; }, atp);
   Task.Factory.StartNew (() =&gt; { <span style="color: #008000; font-weight: bold;">throw</span> <span style="color: #008000; font-weight: bold;">null</span>; }, atp);
})
.ContinueWith (p =&gt; Console.WriteLine (p.Exception),
                    TaskContinuationOptions.OnlyOnFaulted);
</pre>
</div>
<p><img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/CSharp-Threading-Continuations.png" alt="CSharp Threading Continuations"></p>
<p><strong>Продолжения по условию</strong>. По умолчанию запуск 
задачи-продолжения планируется безусловно - всякий раз, когда 
предшествующая задача завершается, выбрасывает исключение или 
отменяется. Вы можете изменить это поведение установкой (комбинируемых 
по ИЛИ) флагов, находящихся в перечислении TaskContinuationOptions. Вот 3
 основных флага, управляющих продолжением по условию (conditional 
continuation):</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">NotOnRanToCompletion = <span style="color: #666666;">0</span>x10000,
NotOnFaulted = <span style="color: #666666;">0</span>x20000,
NotOnCanceled = <span style="color: #666666;">0</span>x40000,
</pre>
</div>
<p>Эти флаги "отнимающие" в том смысле, что чем больше Вы их применяете,
 тем меньше возможности у continuation-задачи выполниться. Для удобства 
вот также следующие заранее скомбинированные значения:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">OnlyOnRanToCompletion = NotOnFaulted | NotOnCanceled,
OnlyOnFaulted = NotOnRanToCompletion | NotOnCanceled,
OnlyOnCanceled = NotOnRanToCompletion | NotOnFaulted
</pre>
</div>
<p><span style="color: #808080;">Примечание: комбинирование всех Not* 
флагов (NotOnRanToCompletion, NotOnFaulted, NotOnCanceled) бессмысленно,
 потому что в результате continuation всегда будет отменено.</span></p>
<p>"RanToCompletion" означает, что запуск будет осуществлен при успешном
 завершении antecedent-задачи, т. е. когда не было отмены (cancellation)
 или не обработанных исключений.</p>
<p>"Faulted" означает, что на antecedent-задаче произошло не обработанное исключение.</p>
<p>"Canceled" означает одно из двух случаев:</p>
<p>• Задача antecedent была отменена (canceled) через её маркер отмены 
(cancellation token). Другими словами, было выброшено исключение внутри 
antecedent-задачи - чье свойство CancellationToken совпало переданному в
 antecedent-задачу, когда она была запущена.<br>• Задача antecedent была
 неявно отменена из-за того, что она не удовлетворила утверждению 
продолжения по условию (conditional continuation predicate).</p>
<p>Важно осознавать, что когда continuation не выполняется на основании 
этих флагов, то continuation не забыто и не отброшено, оно отменено 
(canceled). Это означает, что любые продолжения на самом continuation 
затем будут запущены - кроме случая, когда Вы применили NotOnCanceled. 
Например, предположим следующее:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task t1 = Task.Factory.StartNew (...);
 
Task fault = t1.ContinueWith (ant =&gt; Console.WriteLine (<span style="color: #ba2121;">"fault"</span>),
                              TaskContinuationOptions.OnlyOnFaulted);
 
Task t3 = fault.ContinueWith (ant =&gt; Console.WriteLine (<span style="color: #ba2121;">"t3"</span>));
</pre>
</div>
<p>Как здесь установлено, t3 всегда запланировано на выполнение - даже 
если t1 выбросит исключение. Это потому, что если t1 успешно завершится,
 то задача fault будет отменена, и не будет ограничений на продолжение 
для t3, и t3 запустится без условия.</p>
<p><img src="%D0%9F%D0%BE%D1%82%D0%BE%D0%BA%D0%B8%20%D0%BD%D0%B0%20C%23.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%205_files/CSharp-Threading-ConditionalContinuations.png" alt="CSharp Threading ConditionalContinuations"></p>
<p>Если мы хотим выполнить t3 только если fault реально запустится, то вместо этого нужно написать следующее:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task t3 = fault.ContinueWith (ant =&gt; Console.WriteLine (<span style="color: #ba2121;">"t3"</span>),
                              TaskContinuationOptions.NotOnCanceled);
</pre>
</div>
<p><span style="color: #808080;">Примечание: альтернативно мы могли бы 
указать OnlyOnRanToCompletion; разница будет в том, что t3 тогда не 
запустилась бы, если было бы выброшено исключение в задаче fault.</span></p>
<p><strong>Продолжения с несколькими предшественниками</strong>. Другая 
полезная особенность продолжений - можно запланировать выполнение 
continuation-задач, базируясь на завершении нескольких предшествующих 
(antecedent) задач. ContinueWhenAll планирует выполнение, когда все 
antecedent-задачи были завершены; ContinueWhenAny планирует выполнение, 
когда одна antecedent-задача завершилась. Оба метода определены в классе
 TaskFactory:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> task1 = Task.Factory.StartNew (() =&gt; Console.Write (<span style="color: #ba2121;">"X"</span>));</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> task2 = Task.Factory.StartNew (() =&gt; Console.Write (<span style="color: #ba2121;">"Y"</span>));
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> continuation = Task.Factory.ContinueWhenAll (
   <span style="color: #008000; font-weight: bold;">new</span>[] { task1, task2 }, tasks =&gt; Console.WriteLine (<span style="color: #ba2121;">"Done"</span>));
</pre>
</div>
<p>Этот пример кода выведет "Done" после вывода "XY" или "YX". Аргумент 
tasks в lambda-выражении дает Вам доступ к массиву завершенных задач, 
что полезно, когда antecedent-задачи возвращают данные. Следующий пример
 складывает вместе числа, возвращенные из двух antecedent-задач:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #408080; font-style: italic;">// В реальной жизни task1 и task2 вызывали сложные функции:</span>
Task&lt;<span style="color: #b00040;">int</span>&gt; task1 = Task.Factory.StartNew (() =&gt; <span style="color: #666666;">123</span>);
Task&lt;<span style="color: #b00040;">int</span>&gt; task2 = Task.Factory.StartNew (() =&gt; <span style="color: #666666;">456</span>);
 
Task&lt;<span style="color: #b00040;">int</span>&gt; task3 = Task&lt;<span style="color: #b00040;">int</span>&gt;.Factory.ContinueWhenAll (
   <span style="color: #008000; font-weight: bold;">new</span>[] { task1, task2 }, tasks =&gt; tasks.Sum (t =&gt; t.Result));
 
Console.WriteLine (task3.Result);         <span style="color: #408080; font-style: italic;">// 579</span>
</pre>
</div>
<p style="padding-left: 30px;"><span style="color: #008080;">В этом 
примере мы включали аргумент типа &lt; int&gt; для вызова Task.Factory, 
чтобы разъяснить, что мы получаем обычную фабрику задачи (generic task 
factory). Аргумент типа не обязателен, потому что он будет выведен 
компилятором.</span></p>
<p><strong>Несколько продолжений на одном предшественнике</strong>. 
Вызов ContinueWith больше одного раза на одной и той же задаче создает 
несколько продолжений (continuation-задач) на одном предшественнике 
(antecedent-задаче). Когда antecedent-задача завершится, то все 
continuation-задачи запустятся вместе (если Вы не указали 
TaskContinuationOptions.ExecuteSynchronously, в этом случае 
continuation-задачи будут выполняться последовательно).</p>
<p>Следующий код ждет 1 секунду, и затем выведет либо "XY", либо "YX":</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> t = Task.Factory.StartNew (() =&gt; Thread.Sleep (<span style="color: #666666;">1000</span>));
t.ContinueWith (ant =&gt; Console.Write (<span style="color: #ba2121;">"X"</span>));
t.ContinueWith (ant =&gt; Console.Write (<span style="color: #ba2121;">"Y"</span>));
</pre>
</div>
<p><strong>Планировщики задач и интерфейс пользователя</strong>. 
Планировщик задач (scheduler) выделяет задачи потокам. Все задачи 
связаны с планировщиком задачи, представленным абстрактным классом 
TaskScheduler. Framework предоставляет две конкретные реализации: 
планировщик по умолчанию (default scheduler), который работает в тандеме
 с пулом потоков CLR, и планировщиком контекста синхронизации 
(synchronization context scheduler). Последний разработан (главным 
образом), чтобы помочь Вам с моделью потоков WPF и Windows Forms, 
которые требуют, чтобы к элементам графического интерфейса пользователя 
(UI) и органам его управления (controls) доступ осуществлялся только из 
создавшего их потока. Например предположим, что мы хотим получить некие 
данные из веб-сервиса в виде фонового действия, и затем обновить метку 
WPF с именем lblResult, отражающую результат этого действия. Мы можем 
поделить эту работу на 2 задачи (task):</p>
<p><strong>1</strong>. Вызвать метод, чтобы получить данные из web-сервиса (предшествующая задача, antecedent task).<br><strong>2</strong>. Обновить lblResult полученными результатами (задача продолжения, continuation task).</p>
<p>Если для задачи продолжения (continuation task) указываем планировщик
 контекста синхронизации, полученный, когда было сконструировано окно, 
мы можем безопасно обновить lblResult:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">partial</span> <span style="color: #008000; font-weight: bold;">class</span> <span style="color: #0000ff; font-weight: bold;">MyWindow</span> : Window
{
   TaskScheduler _uiScheduler;   <span style="color: #408080; font-style: italic;">// Декларируем как поле, так что мы можем</span>
                                 <span style="color: #408080; font-style: italic;">// использовать это всюду в нашем классе.</span>
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #0000ff;">MyWindow</span>()
   {    
      InitializeComponent();
 
      <span style="color: #408080; font-style: italic;">// Получение планировщика UI для потока, который создал форму:</span>
      _uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
 
      Task.Factory.StartNew&lt; <span style="color: #b00040;">string</span>&gt; (SomeComplexWebService)
         .ContinueWith (ant =&gt; lblResult.Content = ant.Result, _uiScheduler);
   }
 
   <span style="color: #b00040;">string</span> <span style="color: #0000ff;">SomeComplexWebService</span>() { ... }
}
</pre>
</div>
<p>Также есть возможность написать свой собственный планировщик задач 
(через подкласс TaskScheduler), хотя это нечто такое, что Вы делали бы 
только в очень специализированных сценариях. Для пользовательского 
планирования Вы чаще всего использовали бы TaskCompletionSource, что мы 
скоро рассмотрим.</p>
<p><strong>TaskFactory</strong>. Когда Вы вызываете Task.Factory, то 
создаете статическое свойство на Task, которое возвращает объект 
TaskFactory по умолчанию. Назначение task factory - создавать задачи, 
особенно три вида задач:</p>
<p>• "Обычные" задачи (через StartNew).<br>• Continuation-задачи с несколькими задачами предшественниками (через ContinueWhenAll и ContinueWhenAny).<br>• Задачи, которые обертывают методы, которые следуют за моделью асинхронного программирования (через FromAsync).</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Интересно, 
что TaskFactory является единственным способом достичь последних двух 
целей. В случае StartNew это TaskFactory - просто удобство и технически 
избыточно, Вы можете просто инстанциировать объекты Task и вызвать на 
них Start.</span></p>
<p><strong>Создание своих собственных task factorу</strong>. TaskFactory
 не абстрактная фабрика: Вы можете в действительности инстациировать 
этот класс, и это полезно, когда Вы хотите постоянно создавать задачи, 
используя те же самые (не стандартные) значения для TaskCreationOptions,
 TaskContinuationOptions или TaskScheduler. Например, если мы хотим 
неоднократно создавать долго работающие порожденные задачи, то мы могли 
бы создать пользовательскую фабрику следующим образом:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> factory = <span style="color: #008000; font-weight: bold;">new</span> TaskFactory (
   TaskCreationOptions.LongRunning | TaskCreationOptions.AttachedToParent,
   TaskContinuationOptions.None);
</pre>
</div>
<p>Создание задач тогда просто делается вызовом StartNew на фабрике:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">Task task1 = factory.StartNew (Method1);
Task task2 = factory.StartNew (Method2);
...
</pre>
</div>
<p>Пользовательские опции продолжения применяются, когда вызывается ContinueWhenAll и ContinueWhenAny.</p>
<p><strong>TaskCompletionSource</strong>. Класс Task достигает двух разных вещей:</p>
<p>• Планирует запуск делегата на потоке из пула.<br>• Предоставляет 
богатый набор функций для управления рабочими элементами (продолжения, 
дочерние задачи, перенаправление исключения и т. д.).</p>
<p>Интересно, что эти две вещи не сильно связаны: Вы можете 
задействовать функции задачи для управления рабочими элементами без 
планирования запуска чего-либо на пуле потоков. Класс, который включает 
этот шаблон использования, называется TaskCompletionSource.</p>
<p>Чтобы использовать TaskCompletionSource, Вы просто инстанциируете 
этот класс. Он предоставляет свойство Task, возвращающее задачу, на 
которой Вы можете ждать и подключать к ней продолжения - точно так же, 
как и с любой другой задачей. Однако задача полностью управляется 
объектом TaskCompletionSource через следующие методы:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">class</span> <span style="color: #0000ff; font-weight: bold;">TaskCompletionSource</span>&lt; TResult&gt;
{
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">SetResult</span> (TResult result);
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">SetException</span> (Exception exception);
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">SetCanceled</span>();
 
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #b00040;">bool</span> <span style="color: #0000ff;">TrySetResult</span> (TResult result);
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #b00040;">bool</span> <span style="color: #0000ff;">TrySetException</span> (Exception exception);
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #b00040;">bool</span> <span style="color: #0000ff;">TrySetCanceled</span>();
   ...
}
</pre>
</div>
<p>При вызове больше одного раза SetResult, SetException или SetCanceled
 выбросят исключение; методы Try* вместо этого вернут false.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">TResult 
соответствует типу результата задачи, так что TaskCompletionSource&lt; 
int&gt; даст Вам Task&lt; int&gt;. Если Вы хотите иметь задачу без 
результата, создайте объект TaskCompletionSource и передайте null, когда
 вызываете SetResult. Тогда Вы можете привести тип Task&lt; object&gt; к
 типу Task.</span></p>
<p>Следующий пример напечатает 123 после ожидания 5 секунд:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> source = <span style="color: #008000; font-weight: bold;">new</span> TaskCompletionSource&lt;<span style="color: #b00040;">int</span>&gt;();
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">new</span> <span style="color: #0000ff;">Thread</span> (() =&gt; { Thread.Sleep (<span style="color: #666666;">5000</span>); source.SetResult (<span style="color: #666666;">123</span>); })
   .Start();
 
Task&lt; <span style="color: #b00040;">int</span>&gt; task = source.Task;      <span style="color: #408080; font-style: italic;">// Наша "подчиненная" задача.</span>
Console.WriteLine (task.Result);    <span style="color: #408080; font-style: italic;">// 123</span>
</pre>
</div>
<p>Позже мы покажем, как можно использовать BlockingCollection для 
написания очереди producer/consumer. Тогда мы продемонстрируем, как 
TaskCompletionSource улучшает решение, позволяя поставленным в очередь 
рабочим элементам осуществлять ожидание и отмену.</p>
<p>[<strong>Работа с AggregateException</strong>]</p>
<p>Как мы виделиPLINQ, класс Parallel и Tasks автоматически 
перенаправляют исключения потребителю данных (consumer). Чтобы увидеть, 
почему это важно, рассмотрим следующий запрос LINQ, который выбрасывает 
исключение DivideByZeroException в первой итерации:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">try</span>
{
   <span style="color: #b00040;">var</span> query = <span style="color: #008000; font-weight: bold;">from</span> i <span style="color: #008000; font-weight: bold;">in</span> Enumerable.Range (<span style="color: #666666;">0</span>, <span style="color: #666666;">1000000</span>)
               <span style="color: #008000; font-weight: bold;">select</span> <span style="color: #666666;">100</span> / i;
   ...
}</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">catch</span> (DivideByZeroException)
{
   ...
}
</pre>
</div>
<p>Если мы будем использовать PLINQ для распараллеливания этого запроса с
 игнорированием обработки исключений, то DivideByZeroException вероятно 
было бы выброшено на отдельном потоке с пропуском нашего catch-блока, 
что привело бы к падению приложения.</p>
<p>Следовательно, исключения автоматически перехватываются и 
перенаправляются в вызывающий код. Но к сожалению, это не совсем так же 
просто, как перехват DivideByZeroException. Причина в том, что эти 
библиотеки задействуют многие потоки, и в действительности может быть 
так, что два или большее количество исключений могут быть выброшены 
одновременно. Для гарантии, что о всех исключениях будет сообщено, 
исключения обертываются в контейнер AggregateException, который 
предоставляет свойство InnerExceptions, содержащее перехваченное 
исключение (или исключения):</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">try</span>
{
   <span style="color: #b00040;">var</span> query = <span style="color: #008000; font-weight: bold;">from</span> i <span style="color: #008000; font-weight: bold;">in</span> ParallelEnumerable.Range (<span style="color: #666666;">0</span>, <span style="color: #666666;">1000000</span>)
               <span style="color: #008000; font-weight: bold;">select</span> <span style="color: #666666;">100</span> / i;
   <span style="color: #408080; font-style: italic;">// Перечисление запроса</span>
   ...
}</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">catch</span> (AggregateException aex)
{
   <span style="color: #008000; font-weight: bold;">foreach</span> (Exception ex <span style="color: #008000; font-weight: bold;">in</span> aex.InnerExceptions)
      Console.WriteLine (ex.Message);
}
</pre>
</div>
<p style="padding-left: 30px;"><span style="color: #008080;">И PLINQ, и 
класс Parallel завершают запрос или выполнение цикла, когда встретится 
первое исключение - при этом не будут обработаны какие-либо другие 
элементы или прокрутки тела цикла. Однако может быть выброшено большее 
количество исключений перед завершением текущего цикла. Первое возникшее
 исключение AggregateException будет выдано в свойстве InnerException.</span></p>
<p><strong>Flatten и Handle</strong>. Класс AggregateException предоставляет несколько методов для упрощения обработки исключения: Flatten и Handle.</p>
<p><span style="color: #0000ff;">Flatten</span>. AggregateExceptions 
будут довольно часто содержать другие AggregateExceptions. Пример, когда
 это может случиться - если дочерняя задач выбросит исключение. Вы 
можете исключить любой уровень вложенности для упрощения обработки путем
 вызова Flatten. Этот метод вернет новый экземпляр AggregateException с 
простым плоским списком внутренних исключений:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">catch</span> (AggregateException aex)
{
   <span style="color: #008000; font-weight: bold;">foreach</span> (Exception ex <span style="color: #008000; font-weight: bold;">in</span> aex.Flatten().InnerExceptions)
      myLogWriter.LogException (ex);
}
</pre>
</div>
<p><span style="color: #0000ff;">Handle</span>. Иногда полезно 
перехватывать только определенные типы исключений, чтобы другие типы 
выбрасывались заново. Метод Handle в AggregateException предоставляет 
ярлычок для этой функции. Он принимает предикат исключения, запускаемый с
 каждым внутренним исключением:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Handle</span> (Func&lt; Exception, <span style="color: #b00040;">bool</span>&gt; predicate)
</pre>
</div>
<p>Если этот предикат вернет true, то считается, что исключение 
"обработано". После того, как делегат запустится на каждом исключении, 
произойдет следующее:</p>
<p>• Если все исключения были "обработаны" (делегат вернул true), исключение не будет выброшено повторно.<br>•
 Если были какие-либо исключения, для которых делегат вернул false ("не 
обработано"), новый AggregateException будет построен из этих 
исключений, и они будут повторно выброшены.</p>
<p>Например, следующий код завершится повторным выбрасыванием другого 
AggregateException, которое содержит одно исключение 
NullReferenceException:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> parent = Task.Factory.StartNew (() =&gt; 
{
   <span style="color: #408080; font-style: italic;">// Выбросим 3 исключения сразу с использованием 3 дочерних задач:</span>
   <span style="color: #b00040;">int</span>[] numbers = { <span style="color: #666666;">0</span> };
 
   <span style="color: #b00040;">var</span> childFactory = <span style="color: #008000; font-weight: bold;">new</span> TaskFactory
      (TaskCreationOptions.AttachedToParent, TaskContinuationOptions.None);
 
   childFactory.StartNew (() =&gt; <span style="color: #666666;">5</span> / numbers[<span style="color: #666666;">0</span>]);   <span style="color: #408080; font-style: italic;">// Деление на 0</span>
   childFactory.StartNew (() =&gt; numbers [<span style="color: #666666;">1</span>]);      <span style="color: #408080; font-style: italic;">// Индекс вне диапазона</span>
   childFactory.StartNew (() =&gt; { <span style="color: #008000; font-weight: bold;">throw</span> <span style="color: #008000; font-weight: bold;">null</span>; });  <span style="color: #408080; font-style: italic;">// Null-ссылка</span>
});
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">try</span> { parent.Wait(); }</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">catch</span> (AggregateException aex)
{
   <span style="color: #408080; font-style: italic;">// Обратите внимание, что нам все еще нужно вызвать Flatten:</span>
   aex.Flatten().Handle (ex =&gt;
   {
      <span style="color: #008000; font-weight: bold;">if</span> (ex <span style="color: #008000; font-weight: bold;">is</span> DivideByZeroException)
      {
         Console.WriteLine (<span style="color: #ba2121;">"Divide by zero"</span>);
         <span style="color: #008000; font-weight: bold;">return</span> <span style="color: #008000; font-weight: bold;">true</span>;               <span style="color: #408080; font-style: italic;">// Это исключение "обработано"</span>
      }
      <span style="color: #008000; font-weight: bold;">if</span> (ex <span style="color: #008000; font-weight: bold;">is</span> IndexOutOfRangeException)
      {
         Console.WriteLine (<span style="color: #ba2121;">"Index out of range"</span>);
         <span style="color: #008000; font-weight: bold;">return</span> <span style="color: #008000; font-weight: bold;">true</span>;               <span style="color: #408080; font-style: italic;">// Это исключение "обработано"</span>
      }
      <span style="color: #008000; font-weight: bold;">return</span> <span style="color: #008000; font-weight: bold;">false</span>;           <span style="color: #408080; font-style: italic;">// Все другие исключения будут выброшены повторно</span>
  });
}
</pre>
</div>
<p>[<strong>Конкурентные коллекции</strong>]</p>
<p>Framework 4.0 предоставляет несколько новых коллекций в пространстве 
имен System.Collections.Concurrent. Все они полностью безопасны для 
использования с потоками:</p>
<table cellspacing="1" cellpadding="3" border="0" bgcolor="#8cacbb">
<tbody>
<tr style="background-color: #dee7ec;">
<td><b>Конкурентная коллекция</b></td>
<td><b>Не конкурентный эквивалент</b></td>
</tr>
<tr style="background-color: #ffffff;">
<td>ConcurrentStack&lt; T&gt;</td>
<td>Stack&lt; T&gt;</td>
</tr>
<tr style="background-color: #ffffff;">
<td>ConcurrentQueue&lt; T&gt;</td>
<td>Queue&lt; T&gt;</td>
</tr>
<tr style="background-color: #ffffff;">
<td>ConcurrentBag&lt; T&gt;</td>
<td>нет аналога</td>
</tr>
<tr style="background-color: #ffffff;">
<td>BlockingCollection&lt; T&gt;</td>
<td>нет аналога</td>
</tr>
<tr style="background-color: #ffffff;">
<td>ConcurrentDictionary&lt; TKey,TValue&gt;</td>
<td>Dictionary&lt; TKey,TValue&gt;</td>
</tr>
</tbody>
</table>
<p>Эти конкурентные коллекции могут быть иногда полезны в обычной 
многопоточности, когда Вам нужна thread-safe коллекция. Однако тут есть 
некоторые подводные камни:</p>
<p>• Конкурентные коллекции настроены на параллельное программирование. 
Стандартные коллекции выигрывают у них почти всегда, кроме очень 
конкурентных сценариев.<br>• Thread-safe коллекция не гарантирует, что использующий её код будет thread-safe.<br>•
 Если Вы делаете перечисление по конкурентной коллекции, в то время как 
другой поток её модифицирует, то не будет выброшено исключение. Вместо 
этого Вы получите смесь из старого и нового содержимого.<br>• Нет конкурентной версии для List&lt; T&gt;.<br>•
 Конкурентные классы стека, очереди и Bag внутренне реализованы как 
связанные списки. Это делает их не настолько эффективными по 
использованию памяти, как не конкурентные классы Stack и Queue, но лучше
 для конкурентного доступа, потому что связанные списки способствуют 
реализациям без блокировки или реализациям с минимумом блокировок 
(причина в том, что вставка узла в связанный список требует обновление 
нескольких ссылок, в то время как вставка элемента в структуру наподобие
 List&lt; T&gt; может потребовать перемещения в памяти тысяч 
существующих элементов.</p>
<p>Другими словами, эти коллекции просто не обеспечивают ярлыки для 
использования обычной коллекции с блокировкой. Для демонстрации, если мы
 запустим следующий код в одном потоке:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> d = <span style="color: #008000; font-weight: bold;">new</span> ConcurrentDictionary&lt; <span style="color: #b00040;">int</span>,<span style="color: #b00040;">int</span>&gt;();</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">for</span> (<span style="color: #b00040;">int</span> i = <span style="color: #666666;">0</span>; i &lt; <span style="color: #666666;">1000000</span>; i++) d[i] = <span style="color: #666666;">123</span>;
</pre>
</div>
<p>то он выполнится в 3 раза медленнее, чем этот код:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> d = <span style="color: #008000; font-weight: bold;">new</span> Dictionary&lt; <span style="color: #b00040;">int</span>,<span style="color: #b00040;">int</span>&gt;();</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">for</span> (<span style="color: #b00040;">int</span> i = <span style="color: #666666;">0</span>; i &lt; <span style="color: #666666;">1000000</span>; i++) <span style="color: #008000; font-weight: bold;">lock</span> (d) d[i] = <span style="color: #666666;">123</span>;
</pre>
</div>
<p>Однако чтение из ConcurrentDictionary будет быстрое, потому что чтение работает без блокировки.</p>
<p>Конкурентные коллекции также отличаются от обычных коллекций тем, что
 предоставляют специальные методы для выполнения атомарных операций 
проверка-и-действие, такие как TryPop. Большинство этих методов 
унифицированы через интерфейс IProducerConsumerCollection&lt; T&gt;.</p>
<p><strong>IProducerConsumerCollection&lt; T&gt;</strong>. Коллекция producer/consumer это одна из коллекций, для которых существует два основных применения:</p>
<p>• Добавление элемента (функция "producer").<br>• Получение элемента с удалением его (функция "consumer").</p>
<p>Классические примеры - стеки и очереди. Коллекции producer/consumer 
важны в параллельном программировании, потому что они способствуют 
реализациям без блокировок.</p>
<p>Интерфейс IProducerConsumerCollection&lt; T&gt; представляет 
потокобезопасную коллекцию producer/consumer. Следующие классы реализуют
 этот интерфейс:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">ConcurrentStack&lt; T&gt;
ConcurrentQueue&lt; T&gt;
ConcurrentBag&lt; T&gt;
</pre>
</div>
<p>IProducerConsumerCollection&lt; T&gt; расширяет ICollection, добавляя следующие методы:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">CopyTo</span> (T[] array, <span style="color: #b00040;">int</span> index);
T[] <span style="color: #0000ff;">ToArray</span>();</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">bool</span> <span style="color: #0000ff;">TryAdd</span> (T item);</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">bool</span> <span style="color: #0000ff;">TryTake</span> (<span style="color: #008000; font-weight: bold;">out</span> T item);
</pre>
</div>
<p>Методы TryAdd и TryTake проверяют, может ли быть выполнена операция 
добавление/удаление, и если так, что выполнит добавление/удаление. 
Проверка и действие выполняются атомарно, с устранением надобности в 
блокировке, которая была бы вокруг обычной коллекции:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span> result;</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">lock</span> (myStack) <span style="color: #008000; font-weight: bold;">if</span> (myStack.Count &gt; <span style="color: #666666;">0</span>) result = myStack.Pop();
</pre>
</div>
<p>TryTake вернет false, если коллекция пустая. TryAdd всегда выполнится
 успешно и вернет true в трех предоставленных реализациях. Однако если 
Вы напишете свою собственную коллекцию, которая запрещает дубликаты, то 
заставили бы TryAdd вернуть false, если элемент уже существует (если бы 
Вы писали конкурентный набор).</p>
<p>Определенный элемент, который удаляет TryTake, определяется через подкласс:</p>
<p>• Со стеком TryTake удаляет тот элемент, который был добавлен самым последним.<br>• С очередью TryTake удаляет тот элемент, который был добавлен самым первым.<br>• Вместе с bag TryTake удаляет любой элемент, который может быть удален максимально эффективно.</p>
<p>Эти три конкретные класса часто явно реализуют методы TryTake и 
TryAdd, предоставляя тот же функционал через такие более специфические 
публичные методы, как TryDequeue и TryPop.</p>
<p><strong>ConcurrentBag&lt; T&gt;</strong>. ConcurrentBag&lt; T&gt; 
сохраняет не упорядоченную коллекцию объектов (с разрешенными 
дубликатами). ConcurrentBag&lt; T&gt; подходит для ситуаций, когда Вам 
не нужно заботиться о том, какой элемент Вы получите при вызове Take или
 TryTake.</p>
<p>Преимущество ConcurrentBag&lt; T&gt; над конкурентной очередью или 
стеком в том, что метод Add почти никогда не приводит к состязанию при 
вызове более одного раза. В отличие от этого вызов Add параллельно в 
очереди или в стеке вводит некое состязание (хотя меньшее, чем 
блокировка вокруг не конкурентных коллекций). Вызов Take на конкурентном
 bag также очень эффективно - пока каждый поток не берет больше 
элементов, чем было добавлено.</p>
<p>Внутри конкурентного bag каждый поток получает свой собственный 
приватный связанный список. Элементы, добавленные к этому приватному 
списку, которые принадлежат потоку, вызвавшему Add, устраняют 
состязание. Когда Вы перечисляете содержимое bag, перечислитель 
прогуливается через приватный список каждого потока, уступая каждый из 
их элементов поочередно.</p>
<p>Когда Вы вызываете Take, bag сначала смотрит на приватный список 
текущего потока. Если в нем как минимум один элемент, он легко может 
выполнить задачу, и (в большинстве случаев) без состязания. Но если этот
 список пуст, он должен "украсть" элемент из приватного списка другого 
потока, что потенциально может привести к состязанию.</p>
<p>Таким образом, для точности, вызов Take даст нам элемент, добавленный
 последний раз в этом потоке; если нет элементов в этом потоке, то он 
даст Вам элемент, добавленным последним в другом потоке, выбранном 
случайно.</p>
<p>Конкурентные bag идеальный выбор, когда параллельная операция над 
Вашей коллекцией чаще всего состоит в добавлении элементов - или когда 
добавления (Add) и взятия (Take) на потоке сбалансированы. Мы ранее 
видели подобный пример, когда использовали Parallel.ForEach для 
реализации параллельной проверки орфографии:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> misspellings = <span style="color: #008000; font-weight: bold;">new</span> ConcurrentBag&lt; Tuple&lt; <span style="color: #b00040;">int</span>,<span style="color: #b00040;">string</span>&gt;&gt;();
 
Parallel.ForEach (wordsToTest, (word, state, i) =&gt;
{
   <span style="color: #008000; font-weight: bold;">if</span> (!wordLookup.Contains (word))
      misspellings.Add (Tuple.Create ((<span style="color: #b00040;">int</span>) i, word));
});
</pre>
</div>
<p>Конкурентный bag был бы плохим выбором для очереди producer/consumer,
 потому что элементы добавляются и удаляются в разных потоках.</p>
<p><a name="BlockingCollection"></a></p>
<p><strong>BlockingCollection&lt; T&gt;</strong>. Если Вы вызовите TryTake на любой коллекции producer/consumer, которые мы обсуждали ранее:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">ConcurrentStack&lt; T&gt;
ConcurrentQueue&lt; T&gt;
ConcurrentBag&lt; T&gt;
</pre>
</div>
<p>и коллекция пустая, то метод вернет false. Иногда было бы полезнее в таком сценарии ждать, пока элемент не станет доступным.</p>
<p>Вместо перегрузки методов TryTake с такой функциональностью (которая 
вызвала бы прорыв участников после разрешения маркеров отмени и 
таймаутов), разработчики PFX инкапсулировали этот функционал в 
оборачивающий класс BlockingCollection&lt; T&gt;. Блокирующая коллекция 
обертывает любую коллекцию, которая реализует 
IProducerConsumerCollection&lt; T&gt;, и позволяет Вам взять (Take) 
элемент из обернутой коллекции - с блокировкой, если нет доступных 
элементов.</p>
<p>Блокирующая коллекция также позволяет Вам ограничить локальный размер
 коллекции, блокируя продюсера, если превышен этот размер. Коллекция, 
ограниченная таким способа, называется набором, ограниченным блокировкой
 (bounded blocking collection).</p>
<p>Чтобы использовать BlockingCollection&lt; T&gt;:</p>
<p>1. Инстанциируйте класс, опционально указывая 
IProducerConsumerCollection&lt; T&gt; для обертки и максимальный размер 
(границу) коллекции.<br>2. Вызовите Add или TryAdd, чтобы добавить элементы в нижележащую коллекцию.<br>3. Вызовите Take или TryTake для удаления (потребления) элементов из нижележащей коллекции.</p>
<p>Если Вы вызовите конструктор без передачи коллекции, то этот класс 
автоматически инстанциирует ConcurrentQueue&lt; T&gt;. Методы генерации 
(producing) и потребления (consuming) позволят Вам указать маркеры 
отмены (cancellation tokens) и таймауты. Add и TryAdd могут вызвать 
блокировку, если размер коллекции ограничен; Take и TryTake будут 
вызывать блокировку, пока коллекция пуста.</p>
<p>Другой способ потреблять элементы - вызвать GetConsumingEnumerable. 
Это вернет (потенциально) бесконечную последовательность, которая выдает
 элементы по мере их доступности. Вы можете принудить последовательность
 завершиться вызовом CompleteAdding: этот метод также предотвратит от 
постановки в очередь дальнейших элементов.</p>
<p>Ранее мы написали очередь producer/consumer с использованием Wait и 
Pulse. Вот тот же самый класс, переработанный для использования 
BlockingCollection&lt; T&gt; (обработка исключений оставлена в стороне):</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">class</span> <span style="color: #0000ff; font-weight: bold;">PCQueue</span> : IDisposable
{
   BlockingCollection<action> _taskQ = <span style="color: #008000; font-weight: bold;">new</span> BlockingCollection<action>(); 
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #0000ff;">PCQueue</span> (<span style="color: #b00040;">int</span> workerCount)
   {
      <span style="color: #408080; font-style: italic;">// Создание и запуск отдельной задачи (Task) для каждого consumer:</span>
      <span style="color: #008000; font-weight: bold;">for</span> (<span style="color: #b00040;">int</span> i = <span style="color: #666666;">0</span>; i &lt; workerCount; i++)
         Task.Factory.StartNew (Consume);
   }
 
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Dispose</span>() { _taskQ.CompleteAdding(); }
 
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">EnqueueTask</span> (Action action) { _taskQ.Add (action); }
 
   <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Consume</span>()
   {
      <span style="color: #408080; font-style: italic;">// Эта последовательность, которую мы перечисляем, блокируется,</span>
      <span style="color: #408080; font-style: italic;">// когда нет доступных элементов, и её мы завершим вызовом CompleteAdding.</span>
      <span style="color: #008000; font-weight: bold;">foreach</span> (Action action <span style="color: #008000; font-weight: bold;">in</span> _taskQ.GetConsumingEnumerable())
         action();      <span style="color: #408080; font-style: italic;">// Выполнение задачи.</span>
   }
}
</action></action></pre>
</div>
<p>Из-за того, что мы ничего не передали в конструктор 
BlockingCollection, автоматически инстанциируется конкурентная очередь. 
Если бы мы передали ConcurrentStack, то завершились бы стеком 
producer/consumer.</p>
<p>BlockingCollection также предоставляет статические методы AddToAny и 
TakeFromAny, которые позволяют нам добавлять или получать элемент при 
указании нескольких блокирующих коллекций. Действие action тогда 
сработает на первой коллекции, которая в состоянии обслужить запрос.</p>
<p><strong>Эффективное использование TaskCompletionSource</strong>. 
Пример producer/consumer, которые только что написали, недостаточно 
гибкий в том, что мы не можем отслеживать рабочие элементы после того, 
как они поставлены в очередь. Было бы хорошо, если бы мы могли:</p>
<p>• Узнать, когда рабочий элемент завершен.<br>• Отмена не запустившихся рабочих элементов.<br>• Элегантно обработать любые исключения, выбрасываемые рабочим элементом.</p>
<p>Идеальное решение состояло бы в возврате методом EnqueueTask 
некоторого объекта, который давал бы этот описанный функционал. Хорошая 
новость в том, что такой класс есть, и это все он уже делает - класс 
Task. Все, что нам нужно - перехватить управление задачей через 
TaskCompletionSource:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">class</span> <span style="color: #0000ff; font-weight: bold;">PCQueue</span> : IDisposable
{
   <span style="color: #008000; font-weight: bold;">class</span> <span style="color: #0000ff; font-weight: bold;">WorkItem</span>
   {
      <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">readonly</span> TaskCompletionSource&lt; <span style="color: #b00040;">object</span>&gt; TaskSource;
      <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">readonly</span> Action Action;
      <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">readonly</span> CancellationToken? CancelToken;
 
      <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #0000ff;">WorkItem</span> (
         TaskCompletionSource&lt; <span style="color: #b00040;">object</span>&gt; taskSource,
         Action action,
         CancellationToken? cancelToken)
      {
         TaskSource = taskSource;
         Action = action;
         CancelToken = cancelToken;
      }
   }
 
   BlockingCollection&lt; WorkItem&gt; _taskQ = <span style="color: #008000; font-weight: bold;">new</span> BlockingCollection&lt; WorkItem&gt;();
 
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #0000ff;">PCQueue</span> (<span style="color: #b00040;">int</span> workerCount)
   {
      <span style="color: #408080; font-style: italic;">// Создание и запуск отдельной Task для каждого потребителя (consumer):</span>
      <span style="color: #008000; font-weight: bold;">for</span> (<span style="color: #b00040;">int</span> i = <span style="color: #666666;">0</span>; i &lt; workerCount; i++)
         Task.Factory.StartNew (Consume);
   }
 
   <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Dispose</span>() { _taskQ.CompleteAdding(); }
 
   <span style="color: #008000; font-weight: bold;">public</span> Task <span style="color: #0000ff;">EnqueueTask</span> (Action action) 
   {
      <span style="color: #008000; font-weight: bold;">return</span> <span style="color: #0000ff;">EnqueueTask</span> (action, <span style="color: #008000; font-weight: bold;">null</span>);
   }
 
   <span style="color: #008000; font-weight: bold;">public</span> Task <span style="color: #0000ff;">EnqueueTask</span> (Action action, CancellationToken? cancelToken)
   {
      <span style="color: #b00040;">var</span> tcs = <span style="color: #008000; font-weight: bold;">new</span> TaskCompletionSource&lt; <span style="color: #b00040;">object</span>&gt;();
      _taskQ.Add (<span style="color: #008000; font-weight: bold;">new</span> WorkItem (tcs, action, cancelToken));
      <span style="color: #008000; font-weight: bold;">return</span> tcs.Task;
   }
 
   <span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Consume</span>()
   {
      <span style="color: #008000; font-weight: bold;">foreach</span> (WorkItem workItem <span style="color: #008000; font-weight: bold;">in</span> _taskQ.GetConsumingEnumerable())
      {
         <span style="color: #008000; font-weight: bold;">if</span> (workItem.CancelToken.HasValue &amp;&amp; 
            workItem.CancelToken.Value.IsCancellationRequested)
         {
            workItem.TaskSource.SetCanceled();
         }
         <span style="color: #008000; font-weight: bold;">else</span>
         <span style="color: #008000; font-weight: bold;">try</span>
         {
            workItem.Action();
            workItem.TaskSource.SetResult (<span style="color: #008000; font-weight: bold;">null</span>);  <span style="color: #408080; font-style: italic;">// Показывает завершение</span>
         }
         <span style="color: #008000; font-weight: bold;">catch</span> (OperationCanceledException ex)
         {
            <span style="color: #008000; font-weight: bold;">if</span> (ex.CancellationToken == workItem.CancelToken)
               workItem.TaskSource.SetCanceled();
            <span style="color: #008000; font-weight: bold;">else</span>
               workItem.TaskSource.SetException (ex);
         }
         <span style="color: #008000; font-weight: bold;">catch</span> (Exception ex)
         {
            workItem.TaskSource.SetException (ex);
         }
      }
   }
}
</pre>
</div>
<p>В EnqueueTask мы ставим в очередь рабочий элемент, который 
инкапсулирует целевой делегат и источник завершения задачи - который 
позволяет нам позже управлять задачей, которую мы возвращаем потребителю
 (consumer).</p>
<p>В Consume мы сначала проверяем, была ли задача (task) отменена после 
исключения из очереди рабочего элемента. Если нет, то мы запускаем 
делегата и затем вызываем SetResult на источнике завершения задачи, 
чтобы показать её завершение.</p>
<p>Теперь мы можем использовать этот класс:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> pcQ = <span style="color: #008000; font-weight: bold;">new</span> PCQueue (<span style="color: #666666;">1</span>);
Task task = pcQ.EnqueueTask (() =&gt; Console.WriteLine (<span style="color: #ba2121;">"Easy!"</span>));
...
</pre>
</div>
<p>Мы сейчас можем ждать задачу, выполнять на ней продолжения, 
распространять исключения на продолжения родительских задач, и так 
далее. Другими словами, у нас есть богатство модели задачи с эффектом 
реализации собственного планировщика.</p>
<p><a name="SpinLock_and_SpinWait"></a>[<strong>SpinLock и SpinWait</strong>]</p>
<p>В параллельном программировании частный случай прокруток часто 
предпочтительнее блокировки, так как это позволяет избежать переключения
 контекста и переходы состояния ядра. SpinLock и SpinWait разработаны 
для помощи в таких случаях. Их главное назначение - написание 
пользовательских конструкций синхронизации.</p>
<p style="padding-left: 30px;"><span style="color: #800000;">SpinLock и 
SpinWait это структуры, а не классы! Это дизайнерское решение относится к
 экстремальной технике оптимизации, предназначенной для того, чтобы 
избежать накладных расходов косвенной адресации и сборки мусора. Это 
означает, что Вы должны остерегаться неумышленно копировать экземпляры -
 передавая их, например, в другой метод без модификатора ссылки (ref), 
или декларируя их как поля только для чтения (readonly). Это в частности
 важно для случая SpinLock.</span></p>
<p><strong>SpinLock</strong>. Эта структура позволяет Вам выполнить 
блокировку без трат на переключение контекста, ценой оставления потока в
 циклах (бесполезная занятость). Этот метод допустим в сценариях высокой
 конкуренции, когда блокировка будет очень короткой (например при 
написании с нуля потокобезопасных связанных списков).</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Если Вы 
оставите spinlock на удержании слишком долго (самое большее на 
миллисекунду), это сделает её время сравнимым со слайсом времени, 
порождая переключение контекста точно так же, как это было бы с обычной 
блокировкой. Когда будет запланировано новое выполнение этого кода 
планировщиком, этот код снова уступит управление - получится 
продолжающийся "цикл уступок". Это будет потреблять гораздо меньше 
ресурсов CPU, чем прямая прокрутка - но больше, чем блокирование.</span></p>
<p style="padding-left: 30px;"><span style="color: #008080;">На одноядерной машине spinlock начнет "цикл уступок" немедленно, если имеет место спор за ресурс.</span></p>
<p>Использование SpinLock происходит подобно использованию обычной блокировки, кроме:</p>
<p>• Spinlock это структура (как было упомянуто ранее).<br>• Spinlock не
 реентрантна. Это означает, что Вы не можете вызвать Enter на одной и 
той же SpinLock дважды подряд в одном и том же потоке. Если нарушить это
 правило, то либо будет выброшено исключение (эли это разрешено 
отслеживающим владельцем), либо произойдет deadlock (если отслеживание 
владельцем запрещено). Вы можете указать, разрешать ли отслеживание 
владельцем, когда конструируете spinlock. Отслеживание ухудшает 
производительность.<br>• SpinLock позволяет Вам опрашивать, взята ли 
блокировка, через свойство IsHeld, и если отслеживание владельцем 
разрешено, через IsHeldByCurrentThread.<br>• Нет эквивалента оператору lock языка C#, чтобы предоставить синтаксический сахар для SpinLock.</p>
<p>Другое отличие в том, что когда Вы вызвали Enter, то должны следовать
 шаблону устойчивости с предоставлением аргумента lockTaken (который 
почти всегда делается с блоком try/finally).</p>
<p>Вот пример:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">var</span> spinLock = <span style="color: #008000; font-weight: bold;">new</span> SpinLock (<span style="color: #008000; font-weight: bold;">true</span>);    <span style="color: #408080; font-style: italic;">// Разрешено отслеживание владельцем</span></pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">bool</span> lockTaken = <span style="color: #008000; font-weight: bold;">false</span>;</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">try</span>
{
   spinLock.Enter (<span style="color: #008000; font-weight: bold;">ref</span> lockTaken);
   <span style="color: #408080; font-style: italic;">// Тут какие-то действия...</span>
}</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">finally</span>
{
   <span style="color: #008000; font-weight: bold;">if</span> (lockTaken) spinLock.Exit();
}
</pre>
</div>
<p>Как с обычной блокировкой lock, значение lockTaken будет false после 
вызова Enter если (и только если) метод Enter выбросит исключение и 
блокировка не была взята. Это происходит в очень редких сценариях (таких
 как вызов Abort на потоке, или когда выброшено исключение 
OutOfMemoryException), и позволит Вам надежно узнать, вызван ли был 
впоследствии Exit.</p>
<p>SpinLock также предоставляет метод TryEnter, который принимает таймаут.</p>
<p style="padding-left: 30px;"><span style="color: #008080;">Учитывая 
неловкую семантику SpinLock из-за его типа значения и отсутствие 
поддержки со стороны языка, создается впечатление, чтобы мы страдали 
каждый раз при использовании SpinLock! Дважды подумайте, прежде чем 
отказываться от обычной блокировки.</span></p>
<p>SpinLock имеет смысл чаще всего при написании Ваших собственных 
конструкций синхронизации. И даже тогда spinlock не настолько полезен, 
как это звучит. Он все еще ограничивает конкуренцию, и зря тратит время 
CPU, не делая ничего полезного. Часто для лучший выбор использовать это 
время, делая что-то спекулятивное - с помощью SpinWait.</p>
<p><strong>SpinWait</strong>. Это помогает написать код без блокировки, 
который вместо этого прокручивает циклы. В результате избегаем опасности
 исчерпания ресурсов системы и инверсии приоритета, что иначе могло бы 
возникнуть в случае SpinLock.</p>
<p style="padding-left: 30px;"><span style="color: #800000;">Программирование
 без блокировок с помощью SpinWait довольно трудное, поскольку она 
предназначена для решения проблем многопоточности, которые не решит 
никакая другая конструкция более высокого уровня. Но сначала нужно 
понять, что такое не блокирующая синхронизация [5].</span></p>
<p><strong>Почему нам нужна SpinWait</strong>. Предположим, что мы пишем систему сигнализации на простом флаге, основанную на цикле:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">bool</span> _proceed;</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Test</span>()
{
   <span style="color: #408080; font-style: italic;">// Цикл, пока другой поток не установит _proceed в значение true:</span>
   <span style="color: #008000; font-weight: bold;">while</span> (!_proceed) Thread.MemoryBarrier();
   ...
}
</pre>
</div>
<p>Это всегда будет очень эффективно, если Test запустится, когда 
_proceed уже был установлен в true, или установка _proceed произойдет 
быстро, в течение нескольких циклов. Но теперь предположим, что _proceed
 остался в значении false на несколько секунд - и 4 потока вызвали Test 
одновременно. Тогда эти циклы полностью забьют процессорное время 
четырехядерного CPU! Это приведет к тому, что другие потоки будут 
работать очень медленно (нехватка ресурсов системы) - включая тот самый 
поток, который должен был бы установить _proceed в true (инверсия 
приоритета). Эта ситуация обостряется на одноядерных машинах, где 
прокрутки почти всегда приведут к смене приоритетов (и хотя сегодня 
одноядерные машины встречаются редко, одноядерные виртуальные машины 
обычный случай).</p>
<p>SpinWait решает эти проблемы двумя способами. Во-первых, она 
ограничивает интенсивную трату ресурсов CPU на прокрутки цикла путем 
установки количества итераций, после которых слайс времени будет 
уступаться после каждой прокрутки (вызовом Thread.Yield и Thread.Sleep),
 снижая потребление процессорного времени. Во-вторых, она определяет, 
работает ли программа на одноядерной машине, и если это так, то уступка 
происходит на каждом цикле.</p>
<p><strong>Как использовать SpinWait</strong>. Есть для этого два 
способа. Первый заключается в вызове статического метода SpinUntil. Этот
 метод принимает предикат (и опционально таймаут):</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">bool</span> _proceed;</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Test</span>()
{
   SpinWait.SpinUntil (() =&gt; { Thread.MemoryBarrier(); <span style="color: #008000; font-weight: bold;">return</span> _proceed; });
   ...
}
</pre>
</div>
<p>Другой способ (более гибкий) использования SpinWait - инстанциация структуры и затем вызов SpinOnce в цикле:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">bool</span> _proceed;</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">Test</span>()
{
   <span style="color: #b00040;">var</span> spinWait = <span style="color: #008000; font-weight: bold;">new</span> SpinWait();
   <span style="color: #008000; font-weight: bold;">while</span> (!_proceed) { Thread.MemoryBarrier(); spinWait.SpinOnce(); }
   ...
}
</pre>
</div>
<p>Первый способ является ярлычком второго.</p>
<p><strong>Как работает SpinWait</strong>. В своей текущей реализации 
SpinWait выполняет жесткие прокрутки циклов CPU для 10 итераций перед 
тем, как уступить контекст другим потокам. Однако она не возвращает 
немедленно управление в вызывающий код после каждого из таких циклов: 
вместо этого она вызывает Thread.SpinWait чтобы выполнить прокрутку 
через CLR (и в конечном счете через операционную систему) для установки 
периода времени. Этот период времени изначально равен несколько десятков
 наносекунд, но удваивается с каждой итерацией, пока не произойдет 10 
итераций. Это гарантирует некую предсказуемость на трате процессорного 
времени в фазе интенсивных циклов CPU, которую CLR и операционная 
система может настроить в соответствии с рабочими условиями. Как правило
 это занимает интервал немногих десятков микросекунд - мало, но больше, 
чем цена переключение контекста.</p>
<p>На одноядерной машине SpinWait уступает контекст на каждой итерации. 
Вы можете проверить, уступит ли SpinWait контекст на следующей итерации,
 путем проверки свойства NextSpinWillYield.</p>
<p>Если SpinWait остается в режиме "цикла с уступками" достаточно долго 
(возможно 20 циклов), то она будет периодически засыпать на несколько 
миллисекунд, чтобы дополнительно экономить ресурсы и помочь выполняться 
другим потокам.</p>
<p>Обновления без блокировки с помощью SpinWait и 
Interlocked.CompareExchange. SpinWait вместе с 
Interlocked.CompareExchange может атомарно обновлять поля значением, 
вычисленным относительно его оригинального значения (операция 
read-modify-write). Для примера предположим, что мы хотим умножить поле x
 на 10. Если это сделать напрямую, то это не будет потокобезопасно:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">x = x * <span style="color: #666666;">10</span>;
</pre>
</div>
<p>По той же причине инкремент поля не будет потокобезопасным, как это уже обсуждалось в описании не блокирующей синхронизации [5].</p>
<p>Вот так это правильно делается без блокировки:</p>
<p><strong>1</strong>. Берется снимок x в локальную переменную.<br><strong>2</strong>. Вычисляется новое значение (в этом случае снимок умножается на 10).<br><strong>3</strong>.
 Записывается вычисленное значение обратно, если снимок все еще актуален
 &nbsp;(этот шаг должен быть сделан атомарно вызовом 
Interlocked.CompareExchange).<br><strong>4</strong>. Если снимок устарел, то возврат к шагу 1.</p>
<p>Например:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #b00040;">int</span> x;
 </pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">void</span> <span style="color: #0000ff;">MultiplyXBy</span> (<span style="color: #b00040;">int</span> factor)
{
   <span style="color: #b00040;">var</span> spinWait = <span style="color: #008000; font-weight: bold;">new</span> SpinWait();
   <span style="color: #008000; font-weight: bold;">while</span> (<span style="color: #008000; font-weight: bold;">true</span>)
   {
      <span style="color: #b00040;">int</span> snapshot1 = x;
      Thread.MemoryBarrier();
      <span style="color: #b00040;">int</span> calc = snapshot1 * factor;
      <span style="color: #b00040;">int</span> snapshot2 = Interlocked.CompareExchange (<span style="color: #008000; font-weight: bold;">ref</span> x, calc, snapshot1);
      <span style="color: #008000; font-weight: bold;">if</span> (snapshot1 == snapshot2) <span style="color: #008000; font-weight: bold;">return</span>;    <span style="color: #408080; font-style: italic;">// Никто нас не вытеснял.</span>
      spinWait.SpinOnce();
   }
}
</pre>
</div>
<p style="padding-left: 30px;"><span style="color: #008080;">Мы 
(немного) можем улучшить производительность с помощью вызова 
Thread.MemoryBarrier. Нам это может сойти с рук, потому что 
CompareExchange все равно генерирует барьер памяти - так что самое 
худшее, что может случиться, это дополнительная прокрутка, если 
окажется, что в snapshot1 прочитано устаревшее на предыдущей итерации 
значение.</span></p>
<p>Interlocked.CompareExchange обновляет поле указанным значением, если 
текущее значение поля совпадает с третьим аргументом. Тогда будет 
возвращено старое значение поля, так что Вы можете проверить успех 
обновления путем сравнения с оригинальным snapshot. Если значения 
различаются, то это означает, что другой поток вытеснил Вас, тогда нужно
 вернуться в начало и сделать другую попытку модификации значения.</p>
<p>CompareExchange перегружен, чтобы также работать с типом object. Мы 
можем использовать эту перегрузку путем написания метода обновления без 
блокировки, который работает со всеми ссылочными типами:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">static</span> <span style="color: #008000; font-weight: bold;">void</span> LockFreeUpdate&lt; T&gt; (<span style="color: #008000; font-weight: bold;">ref</span> T field, Func &lt; T, T&gt; updateFunction)
   <span style="color: #008000; font-weight: bold;">where</span> T : class
{
   <span style="color: #b00040;">var</span> spinWait = <span style="color: #008000; font-weight: bold;">new</span> SpinWait();
   <span style="color: #008000; font-weight: bold;">while</span> (<span style="color: #008000; font-weight: bold;">true</span>)
   {
      T snapshot1 = field;
      T calc = updateFunction (snapshot1);
      T snapshot2 = Interlocked.CompareExchange (<span style="color: #008000; font-weight: bold;">ref</span> field, calc, snapshot1);
      <span style="color: #008000; font-weight: bold;">if</span> (snapshot1 == snapshot2) <span style="color: #008000; font-weight: bold;">return</span>;
      spinWait.SpinOnce();
   }
}
</pre>
</div>
<p>Вот так мы можем использовать этот метод, чтобы написать 
потокобезопасное событие без блокировок (это то, что фактически по 
умолчанию с событиями делает компилятор C# 4.0):</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">EventHandler _someDelegate;</pre>
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">event</span> EventHandler SomeEvent
{
   <span style="color: #008000; font-weight: bold;">add</span>    { LockFreeUpdate (<span style="color: #008000; font-weight: bold;">ref</span> _someDelegate, d =&gt; d + <span style="color: #008000; font-weight: bold;">value</span>); }
   <span style="color: #008000; font-weight: bold;">remove</span> { LockFreeUpdate (<span style="color: #008000; font-weight: bold;">ref</span> _someDelegate, d =&gt; d - <span style="color: #008000; font-weight: bold;">value</span>); }
}
</pre>
</div>
<p><strong>SpinWait против SpinLock</strong>. Мы могли бы решить эти 
проблемы по-другому, обернув доступ к общему полю вокруг SpinLock. Хотя 
проблема со spin locking состоит в том, что это позволяет в любой момент
 времени выполнять только один поток - даже при том, что spinlock 
(обычно) устраняет накладные расходы на переключение контекста. Вместе 
со SpinWait мы можем выполнить поток спекулятивно и предположить 
отсутствие состязания. Если нас вытеснили, то просто попытаемся снова. 
Трата времени CPU на что-то полезное намного лучше, чем трата его на 
spinlock!</p>
<p>В завершение рассмотрим следующий класс:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008000; font-weight: bold;">class</span> <span style="color: #0000ff; font-weight: bold;">Test</span>
{
   ProgressStatus _status = <span style="color: #008000; font-weight: bold;">new</span> ProgressStatus (<span style="color: #666666;">0</span>, <span style="color: #ba2121;">"Starting"</span>);
 
   <span style="color: #008000; font-weight: bold;">class</span> <span style="color: #0000ff; font-weight: bold;">ProgressStatus</span>    <span style="color: #408080; font-style: italic;">// Не измененный класс</span>
   {
      <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">readonly</span> <span style="color: #b00040;">int</span> PercentComplete;
      <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #008000; font-weight: bold;">readonly</span> <span style="color: #b00040;">string</span> StatusMessage;
 
      <span style="color: #008000; font-weight: bold;">public</span> <span style="color: #0000ff;">ProgressStatus</span> (<span style="color: #b00040;">int</span> percentComplete, <span style="color: #b00040;">string</span> statusMessage)
      {
         PercentComplete = percentComplete;
         StatusMessage = statusMessage;
      }
   }
}
</pre>
</div>
<p>Мы можем использовать наш метод LockFreeUpdate для "инкремента" поля PercentComplete в _status следующим образом:</p>
<!-- HTML generated using hilite.me -->
<div style="background: #f8f8f8; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">LockFreeUpdate (<span style="color: #008000; font-weight: bold;">ref</span> _status,
   s =&gt; <span style="color: #008000; font-weight: bold;">new</span> ProgressStatus (s.PercentComplete + <span style="color: #666666;">1</span>, s.StatusMessage));
</pre>
</div>
<p>Обратите внимание, что мы создаем новый объект ProgressStatus на 
основе существующих значений. Благодаря методу LockFreeUpdate акт чтения
 существующего значения PercentComplete, его инкремент запись обратно не
 могут быть вытеснены небезопасно: любое вытеснение будет надежно 
детектировано, что вызовет прокрутку и повторную попытку.</p>
<p>[<strong>Ссылки</strong>]</p>
<p><strong>1</strong>. Threading in C# PART 5: PARALLEL PROGRAMMING site:albahari.com.<br><strong>2</strong>. <a href="http://microsin.net/programming/pc/threading-in-csharp-part-1-getting-started.html">Потоки на C#. Часть 1: введение</a>.<br><strong>3</strong>. <a href="http://microsin.net/programming/pc/threading-in-csharp-part-2-basic-synchronization.html">Потоки на C#. Часть 2: основы синхронизации</a>.<br><strong>4</strong>. <a href="http://microsin.net/programming/pc/threading-in-csharp-part-3-using-threads.html">Потоки на C#. Часть 3: использование потоков</a>.<br><strong>5</strong>. <a href="http://microsin.net/programming/pc/threading-in-csharp-part-4-advanced-threading.html">Потоки на C#. Часть 4: продвинутое использование</a>.<br><strong>6</strong>. The .NET Programmer’s Playground site:linqpad.net.<br><strong>7</strong>. Закон Амдала site:wikipedia.org.</p></td>
</tr>

</tbody></table>
<span class="article_separator">&nbsp;</span>

</html>